name: Deploy

on:
  push:
    branches:
      - main
      - dev
    paths:
      - '.github/workflows/deploy.yml'
      - 'api/**'
      - 'webapp/**'
      - 'docker/**'
      - '**/Dockerfile'
  workflow_dispatch:
    inputs:
      branch:
        description: 'Target branch to deploy'
        required: false
        default: ''
        type: choice
        options:
          - 'main'
          - 'dev'

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'
  TARGET_BRANCH: ${{ github.event.inputs.branch || github.ref_name }}

permissions:
  contents: read
  packages: write
  attestations: write
  id-token: write

jobs:
  required-checks:
    uses: ./.github/workflows/required-checks.yml

  build:
    needs: required-checks
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
    secrets: inherit

  # Legacy deploy job (disabled - Docker containers handle deployment now)
  # deploy:
  #   name: deploy
  #   runs-on: ubuntu-latest
  #   needs: [required-checks, build]
  #   if: false  # Disabled in favor of Docker containers

  # post-deploy:
  #   name: post-deploy
  #   needs: [deploy]
  #   uses: ./.github/workflows/post-deploy.yml
  #   with:
  #     environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
  #   secrets: inherit

  # Legacy rollback (disabled - Docker containers handle rollback now)

  # Docker container deployments are the primary deployment method
  docker-canary-dev:
    name: docker-canary-dev
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/dev' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'dev'))

    env:
      ENVIRONMENT: Development
      DEPLOY_PATH: /var/www/livrolog-dev
      GHCR_PAT: ${{ secrets.GHCR_PAT }}
      TARGET_BRANCH: dev

    steps:
      - name: Deploy canary containers (livrolog-dev)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_PAT,GITHUB_SHA,GITHUB_REF_NAME,TARGET_BRANCH
          script: |
            set -euo pipefail
            DOCKER_DIR="/var/www/livrolog-dev/docker"
            OWNER="arnonrdp"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            sudo mkdir -p "$DOCKER_DIR"
            sudo chown -R bitnami:bitnami /var/www/livrolog-dev
            cd "$DOCKER_DIR"

            # Login condicional no GHCR (se GHCR_PAT estiver definido e não vazio)
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u arnonrdp --password-stdin
            else
              echo "Aviso: GHCR_PAT vazio. Se os pacotes forem privados, o pull falhará."
            fi

            # Encontrar porta livre entre 8082-8090
            WEB_PORT=""
            for port in {8082..8090}; do
              if ! ss -ltn | grep -q ":${port} "; then
                WEB_PORT=$port
                break
              fi
            done

            if [ -z "$WEB_PORT" ]; then
              echo "❌ Nenhuma porta disponível entre 8082-8090. Verifique processos em execução." >&2
              exit 1
            fi

            echo "🔍 Usando porta ${WEB_PORT} para web"

            # Opcional: limpar containers antigos do LivroLog
            docker rm -f livrolog-web-dev livrolog-web 2>/dev/null || true

            # Gera compose dev
            cat > docker-compose.dev.yml << EOF
            name: livrolog_dev
            services:
              web:
                image: REPLACE_WEB_IMAGE
                container_name: livrolog-web-dev
                restart: always
                ports:
                  - "${WEB_PORT}:80"
                healthcheck:
                  test: ["CMD", "curl", "-fsS", "http://localhost/healthz"]
                  interval: 15s
                  timeout: 3s
                  retries: 10
                depends_on:
                  - api
              api:
                image: REPLACE_API_IMAGE
                container_name: livrolog-api-dev
                restart: always
                env_file:
                  - /var/www/livrolog-dev/shared/.env.dev
                environment:
                  - DB_HOST=127.0.0.1
                  - DB_PORT=3306
                  - REDIS_HOST=127.0.0.1
                  - REDIS_PORT=6379
                network_mode: host
                volumes:
                  - /var/www/livrolog-dev/shared/storage:/var/www/html/storage
                healthcheck:
                  test: ["CMD", "php", "artisan", "about"]
                  interval: 10s
                  timeout: 5s
                  retries: 30
                  start_period: 60s
            EOF

            # Ler tag anterior para rollback real em caso de falha
            PREV_TAG=$(cat .last_tag_dev 2>/dev/null || echo "dev")
            echo "📋 Tag anterior para rollback: ${PREV_TAG}"

            # Resolve tag existente: dev-<sha> -> <sha> -> dev
            BRANCH="${TARGET_BRANCH:-${GITHUB_REF_NAME:-dev}}"
            SHA="${GITHUB_SHA}"
            CANDIDATES=("${BRANCH}-${SHA}" "${SHA}" "${BRANCH}")

            RESOLVED_TAG=""
            for tag in "${CANDIDATES[@]}"; do
              if docker manifest inspect "${IMAGE_WEB}:${tag}" >/dev/null 2>&1 && docker manifest inspect "${IMAGE_API}:${tag}" >/dev/null 2>&1; then
                RESOLVED_TAG="${tag}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "❌ Nenhuma tag encontrada (testadas: ${CANDIDATES[*]}). Verifique as tags publicadas no GHCR." >&2
              exit 1
            fi

            echo "$RESOLVED_TAG" > .resolved_tag_dev
            export TAG="$RESOLVED_TAG"

            # Define compose command para dev
            # Centraliza flags comuns para operações do docker compose dev
            COMPOSE="docker compose -p livrolog_dev -f docker-compose.dev.yml"
            echo "📋 Using compose command: $COMPOSE"

            # Substitui as imagens no compose
            sed -i "s|REPLACE_WEB_IMAGE|${IMAGE_WEB}:${TAG}|g" docker-compose.dev.yml
            sed -i "s|REPLACE_API_IMAGE|${IMAGE_API}:${TAG}|g" docker-compose.dev.yml

            # Verificar .env e storage antes do up (fail-fast com mensagem clara)
            test -f /var/www/livrolog-dev/shared/.env.dev || { echo "❌ /var/www/livrolog-dev/shared/.env.dev não existe"; exit 1; }
            test -d /var/www/livrolog-dev/shared/storage || { echo "❌ /var/www/livrolog-dev/shared/storage não existe"; exit 1; }

            # Persistir porta escolhida para debug
            echo "$WEB_PORT" > .web_port_dev

            # Pull e start
            $COMPOSE pull
            $COMPOSE up -d --remove-orphans

            # Espera healthchecks (aumentado timeout para 180s)
            echo "Waiting for services to be healthy (max 180s)…"
            deadline=$((SECONDS+180))
            while true; do
              web_ok=0; api_ok=0
              curl -fsS "http://localhost:${WEB_PORT}/healthz" >/dev/null 2>&1 && web_ok=1
              docker exec livrolog-api-dev php artisan about >/dev/null 2>&1 && api_ok=1
              if [ "$web_ok" -eq 1 ] && [ "$api_ok" -eq 1 ]; then break; fi
              if [ $SECONDS -ge $deadline ]; then
                echo "❌ Health checks failed, rolling back para tag anterior…"
                echo "=== Diagnóstico de containers ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
                echo "=== Health status da API ==="
                if command -v jq >/dev/null 2>&1; then
                  docker inspect --format='{{json .State.Health}}' livrolog-api-dev | jq . || true
                else
                  echo "⚠️ jq não encontrado, exibindo JSON raw:"
                  docker inspect --format='{{json .State.Health}}' livrolog-api-dev || true
                fi
                echo "=== Logs da API (últimas 80 linhas) ==="
                docker logs --tail=80 livrolog-api-dev || true
                echo "=== Logs da Web (últimas 80 linhas) ==="
                docker logs --tail=80 livrolog-web-dev || true
                echo "=== Iniciando rollback para tag: ${PREV_TAG} ==="
                export TAG="$PREV_TAG"
                sed -i "s|ghcr.io/.*/livrolog-web:.*|${IMAGE_WEB}:${TAG}|g" docker-compose.dev.yml
                sed -i "s|ghcr.io/.*/livrolog-api:.*|${IMAGE_API}:${TAG}|g" docker-compose.dev.yml
                $COMPOSE pull
                $COMPOSE up -d --remove-orphans
                exit 1
              fi
              sleep 5
            done

            # Migrations e caches
            docker exec livrolog-api-dev php artisan migrate --force
            docker exec livrolog-api-dev php artisan config:clear || true
            docker exec livrolog-api-dev php artisan cache:clear || true

            # Deploy bem-sucedido: atualizar .last_tag_dev para próximos rollbacks
            echo "$RESOLVED_TAG" > .last_tag_dev
            echo "📝 Tag $RESOLVED_TAG salva para rollbacks futuros"

            echo "✅ Canary OK em http://$(hostname -I | awk '{print $1}'):${WEB_PORT}"
            echo "🎯 Deployed branch: ${TARGET_BRANCH:-dev}"

  docker-canary-prod:
    name: docker-canary-prod
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'main'))

    env:
      ENVIRONMENT: Production
      DEPLOY_PATH: /var/www/livrolog
      GHCR_PAT: ${{ secrets.GHCR_PAT }}
      APP_KEY: ${{ secrets.APP_KEY }}
      DEPLOY_DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      DB_HEALTH_TIMEOUT: ${{ secrets.DB_HEALTH_TIMEOUT || 600 }}
      REDIS_HEALTH_TIMEOUT: '300'
      TARGET_BRANCH: main

    steps:
      - name: Checkout code for compose file
        uses: actions/checkout@v4

      - name: Deploy production containers
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_PAT,GITHUB_SHA,GITHUB_REF_NAME,APP_KEY,DEPLOY_DB_PASSWORD,DB_HEALTH_TIMEOUT,REDIS_HEALTH_TIMEOUT,TARGET_BRANCH
          script: |
            set -euo pipefail
            DOCKER_DIR="/var/www/livrolog/docker"
            OWNER="arnonrdp"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            # Display deployment configuration
            echo "=================================================="
            echo "🚀 Starting production deployment (branch: ${TARGET_BRANCH:-main})"
            echo "Using internal MariaDB + Redis containers"
            echo "DB_HEALTH_TIMEOUT=${DB_HEALTH_TIMEOUT:-600}s, REDIS_HEALTH_TIMEOUT=${REDIS_HEALTH_TIMEOUT:-300}s"
            echo "Deployment is idempotent - auto-normalizes .env configuration"
            echo "=================================================="

            # Create all required directories
            echo "📁 Creating required directories..."
            sudo mkdir -p "$DOCKER_DIR"
            sudo mkdir -p /var/www/livrolog/shared/{storage,db}

            # Set proper permissions (999:999 is the default MariaDB container user)
            sudo chown -R 999:999 /var/www/livrolog/shared/db
            sudo chown -R "$USER:$USER" /var/www/livrolog
            cd "$DOCKER_DIR"

            # Auto-provision and normalize .env (idempotent)
            echo "🔧 Normalizing .env configuration..."
            sudo touch /var/www/livrolog/shared/.env
            sudo chown -R "$USER:$USER" /var/www/livrolog/shared/.env

            # Função POSIX para gerar APP_KEY compatível com Laravel (sem depender de imagens externas)
            gen_app_key() {
              if command -v head >/dev/null 2>&1 && command -v base64 >/dev/null 2>&1; then
                head -c 32 /dev/urandom | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              elif command -v openssl >/dev/null 2>&1; then
                openssl rand -base64 32 | tr -d '\n' | awk '{print "base64:" $0}'
              else
                dd if=/dev/urandom bs=32 count=1 2>/dev/null | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              fi
            }

            # 1) Tenta usar a secret APP_KEY; se ausente/inválida, gera automaticamente
            APP_KEY_CAND="${APP_KEY:-}"
            echo "🔍 Validating APP_KEY candidate: [${#APP_KEY_CAND} chars]${APP_KEY_CAND:+ (has value)}${APP_KEY_CAND:- (empty)}"
            
            # Regex pattern for 44-char base64 key (explicitly define for clarity)
            APP_KEY_PATTERN='^base64:[A-Za-z0-9+/=]{44}$'
            
            if ! printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN"; then
              echo "⚠️ APP_KEY secret ausente/inválido; gerando automaticamente..."
              APP_KEY_CAND="$(gen_app_key || true)"
              echo "🔧 Generated new APP_KEY: [${#APP_KEY_CAND} chars]"
            else
              echo "✅ APP_KEY from secret is valid"
            fi

            # 2) Valida e grava no .env (operação atômica)
            if printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN"; then
              tmpfile="$(mktemp)"
              # Remove qualquer APP_KEY existente e escreve a nova (seguro p/ caracteres especiais)
              grep -v '^APP_KEY=' /var/www/livrolog/shared/.env > "$tmpfile" || true
              printf 'APP_KEY=%s\n' "$APP_KEY_CAND" >> "$tmpfile"
              mv "$tmpfile" /var/www/livrolog/shared/.env
              echo "✅ APP_KEY provisionada/atualizada em /var/www/livrolog/shared/.env"
            else
              echo "❌ Falha ao provisionar APP_KEY automaticamente (não foi possível obter uma chave válida)"
              exit 1
            fi

            # Normalize database and Redis configuration (idempotent)
            # This step ensures the .env always has correct values for internal services
            # regardless of previous state, making the deployment fully idempotent
            echo "📝 Normalizing database and Redis configuration in .env..."

            # Read existing values to preserve from .env file
            eval $(grep -E '^(DB_DATABASE|DB_USERNAME|DB_PASSWORD)=' /var/www/livrolog/shared/.env 2>/dev/null || true)

            # Bootstrap database credentials from GitHub Secrets if not present in .env
            if [ -z "${DB_DATABASE:-}" ]; then
              DB_DATABASE="livrolog"
              echo "📝 Using default DB_DATABASE: ${DB_DATABASE}"
            fi
            
            if [ -z "${DB_USERNAME:-}" ]; then
              DB_USERNAME="root"  
              echo "📝 Using default DB_USERNAME: ${DB_USERNAME}"
            fi
            
            # Bootstrap DB_PASSWORD - prioridade: .env -> GitHub Secret -> falha
            # DB_PASSWORD_FROM_ENV: valor lido do arquivo .env no servidor
            # DEPLOY_DB_PASSWORD: valor vindo da GitHub Secret via environment variable
            DB_PASSWORD_FROM_ENV="${DB_PASSWORD:-}"  # From .env file on server
            DEPLOY_DB_PASSWORD="${DEPLOY_DB_PASSWORD:-}"  # From GitHub Secret (environment variable)
            
            if [ -n "${DB_PASSWORD_FROM_ENV}" ]; then
              DB_PASSWORD="${DB_PASSWORD_FROM_ENV}"
              echo "📝 Using DB_PASSWORD from existing .env file"
            elif [ -n "${DEPLOY_DB_PASSWORD}" ]; then
              DB_PASSWORD="${DEPLOY_DB_PASSWORD}"
              echo "📝 Bootstrapping DB_PASSWORD from GitHub Secret"
            else
              echo "❌ DB_PASSWORD not found in .env and DEPLOY_DB_PASSWORD secret not provided"
              exit 1
            fi

            # Create normalized .env with correct values (atomic operation)
            tmpfile="$(mktemp)"

            # Copy all non-DB/Redis lines
            grep -v -E '^(APP_ENV|DB_CONNECTION|DB_HOST|DB_PORT|DB_DATABASE|DB_USERNAME|DB_PASSWORD|REDIS_HOST|REDIS_PORT)=' /var/www/livrolog/shared/.env > "$tmpfile" 2>/dev/null || true

            # Append normalized configuration
            cat >> "$tmpfile" << ENVEOF
            APP_ENV=production
            DB_CONNECTION=mysql
            DB_HOST=mariadb
            DB_PORT=3306
            DB_DATABASE=${DB_DATABASE}
            DB_USERNAME=${DB_USERNAME}
            DB_PASSWORD=${DB_PASSWORD}
            REDIS_HOST=redis
            REDIS_PORT=6379
            ENVEOF

            # Atomically replace .env
            mv "$tmpfile" /var/www/livrolog/shared/.env
            echo "✅ .env normalized for internal MariaDB and Redis"

            # Pre-checks: verify environment and infrastructure
            echo "🔍 Performing pre-deployment checks..."

            # Check 1: required directories exist
            test -f /var/www/livrolog/shared/.env || { echo "❌ /var/www/livrolog/shared/.env não existe"; exit 1; }
            test -d /var/www/livrolog/shared/storage || { echo "❌ /var/www/livrolog/shared/storage não existe"; exit 1; }
            test -d /var/www/livrolog/shared/db || { echo "❌ /var/www/livrolog/shared/db não existe"; exit 1; }

            # Validação correta da APP_KEY no .env (exatamente 44 chars após base64:)
            echo "🔍 Validating APP_KEY in .env file..."
            
            # Extract and validate APP_KEY from .env
            ENV_APP_KEY=$(grep '^APP_KEY=' /var/www/livrolog/shared/.env 2>/dev/null | cut -d'=' -f2- && true || echo "")
            echo "Found APP_KEY in .env: [${#ENV_APP_KEY} chars]${ENV_APP_KEY:+ (has value)}${ENV_APP_KEY:- (missing)}"
            
            if ! printf '%s' "$ENV_APP_KEY" | grep -Eq "$APP_KEY_PATTERN"; then
              echo "❌ APP_KEY inválido/ausente em /var/www/livrolog/shared/.env"
              echo "Expected pattern: $APP_KEY_PATTERN"
              echo "Actual value: '$ENV_APP_KEY'"
              exit 1
            fi
            echo "✅ APP_KEY validation passed"

            # Reload normalized values for validation
            eval $(grep -E '^(DB_CONNECTION|DB_HOST|DB_PORT|DB_DATABASE|DB_USERNAME|DB_PASSWORD|REDIS_HOST|REDIS_PORT)=' /var/www/livrolog/shared/.env)

            # Validate critical configuration
            echo "Validating normalized configuration..."
            [ "${DB_CONNECTION}" = "mysql" ] || { echo "❌ DB_CONNECTION validation failed"; exit 1; }
            [ "${DB_HOST}" = "mariadb" ] || { echo "❌ DB_HOST validation failed"; exit 1; }
            [ "${DB_PORT}" = "3306" ] || { echo "❌ DB_PORT validation failed"; exit 1; }
            [ "${REDIS_HOST}" = "redis" ] || { echo "❌ REDIS_HOST validation failed"; exit 1; }
            [ "${REDIS_PORT}" = "6379" ] || { echo "❌ REDIS_PORT validation failed"; exit 1; }
            [ -n "${DB_DATABASE}" ] || { echo "❌ DB_DATABASE is empty"; exit 1; }
            [ -n "${DB_USERNAME}" ] || { echo "❌ DB_USERNAME is empty"; exit 1; }
            [ -n "${DB_PASSWORD}" ] || { echo "❌ DB_PASSWORD is empty"; exit 1; }

            echo "✅ Configuration validated successfully"

            # Login to GHCR if PAT is available
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u arnonrdp --password-stdin
            else
              echo "⚠️ GHCR_PAT not set. Using public access."
            fi

            # Resolve tag: prefer 'prod', fallback to SHA
            BRANCH="${TARGET_BRANCH:-${GITHUB_REF_NAME:-main}}"
            SHA="${GITHUB_SHA}"
            CANDIDATES=("prod" "${SHA}" "${BRANCH}")

            RESOLVED_TAG=""
            for tag in "${CANDIDATES[@]}"; do
              if docker manifest inspect "${IMAGE_WEB}:${tag}" >/dev/null 2>&1 && docker manifest inspect "${IMAGE_API}:${tag}" >/dev/null 2>&1; then
                RESOLVED_TAG="${tag}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "❌ Nenhuma tag encontrada (testadas: ${CANDIDATES[*]})"
              exit 1
            fi

            echo "🏷️ Using resolved tag: $RESOLVED_TAG"
            export TAG="$RESOLVED_TAG"
            export OWNER="$OWNER"

            # Create production compose file with MariaDB and Redis
            cat > docker-compose.prod.yml << 'EOF'
            # docker-compose.prod.yml
            # Production Docker Compose with internal MariaDB and Redis

            name: livrolog

            services:
              # MariaDB Database (internal, no exposed ports)
              mariadb:
                image: mariadb:10.11-jammy
                restart: always
                environment:
                  - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
                  - MYSQL_DATABASE=${DB_DATABASE}
                  - MYSQL_USER=${DB_USERNAME}
                  - MYSQL_PASSWORD=${DB_PASSWORD}
                networks:
                  - livrolog-net
                volumes:
                  - /var/www/livrolog/shared/db:/var/lib/mysql
                healthcheck:
                  # Uses root user since DB_USERNAME defaults to 'root' in this deployment
                  # For non-root users, use: mysql --silent --connect-timeout=5 -u $$MYSQL_USER -p$$MYSQL_PASSWORD -e 'SELECT 1'
                  test: ["CMD-SHELL", "mysql --silent --connect-timeout=5 -u root -p$$MYSQL_ROOT_PASSWORD -e 'SELECT 1' >/dev/null 2>&1"]
                  interval: 10s
                  timeout: 5s
                  retries: 30
                  start_period: 90s

              # Redis Cache (internal, no exposed ports)
              redis:
                image: redis:7-alpine
                restart: always
                networks:
                  - livrolog-net
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 5s
                  timeout: 3s
                  retries: 30
                  start_period: 10s

              # Laravel API with Nginx + PHP-FPM (serves on port 8080)
              api:
                image: ghcr.io/${OWNER:-arnonrdp}/livrolog-api:${TAG:-prod}
                restart: always
                environment:
                  # Use containerized services
                  - DB_HOST=mariadb
                  - DB_PORT=3306
                  - REDIS_HOST=redis
                  - REDIS_PORT=6379
                ports:
                  - "127.0.0.1:18081:8080"
                networks:
                  - livrolog-net
                volumes:
                  # Mount shared storage and .env from existing deployment
                  - /var/www/livrolog/shared/storage:/var/www/html/storage
                  - /var/www/livrolog/shared/.env:/var/www/html/.env:ro
                extra_hosts:
                  - "host.docker.internal:host-gateway"
                depends_on:
                  mariadb:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                healthcheck:
                  test: ["CMD", "curl", "-fsS", "http://localhost:8080/health"]
                  interval: 15s
                  timeout: 5s
                  retries: 10
                  start_period: 30s

              # Vue/Quasar WebApp served by Nginx
              web:
                image: ghcr.io/${OWNER:-arnonrdp}/livrolog-web:${TAG:-prod}
                restart: always
                ports:
                  - "127.0.0.1:18080:80"
                networks:
                  - livrolog-net
                depends_on:
                  api:
                    condition: service_healthy
                healthcheck:
                  test: ["CMD", "sh", "-c", "curl -fsS http://localhost/healthz"]
                  interval: 15s
                  timeout: 10s
                  retries: 10
                  start_period: 30s

            networks:
              livrolog-net:
                name: livrolog-net
                driver: bridge
            EOF

            # Save current tag for rollback
            echo "$RESOLVED_TAG" > .resolved_tag_prod
            echo "$RESOLVED_TAG" > .last_tag_prod

            # Define compose command with env-file to ensure all variables are loaded
            # $COMPOSE centraliza flags comuns: --env-file garante que DB_PASSWORD e outras vars sejam lidas do .env
            # -p livrolog define project name consistente, -f especifica o compose file de produção
            COMPOSE="docker compose --env-file /var/www/livrolog/shared/.env -p livrolog -f docker-compose.prod.yml"
            echo "📋 Using compose command: $COMPOSE"

            # Check for optional database seeding
            echo "Checking for database seeding..."
            if [ ! -f /var/www/livrolog/shared/db/ibdata1 ] && [ -f /var/www/livrolog/shared/db-seed.sql ]; then
              echo "🌱 Empty database detected with seed file available - will seed after MariaDB starts"
              SEED_REQUIRED=1
            elif [ ! -f /var/www/livrolog/shared/db/ibdata1 ]; then
              echo "🆕 Empty database detected (first run)"
              echo "ℹ️ Para semear: coloque o dump em /var/www/livrolog/shared/db-seed.sql e reexecute o workflow"
              SEED_REQUIRED=0
            else
              echo "✅ Existing database detected"
              SEED_REQUIRED=0
            fi

            # Preflight cleanup - stop existing containers and remove orphans
            echo "🧹 Preflight cleanup - ensuring idempotent deployment..."
            echo "Stopping existing compose project if running..."
            $COMPOSE down --remove-orphans || true

            echo "Removing any orphaned containers by name..."
            docker rm -f livrolog-api livrolog-web livrolog-mariadb || true
            docker rm -f livrolog_api_1 livrolog_web_1 livrolog_mariadb_1 || true

            echo "Cleaning up old networks..."
            docker network rm livrolog-net || true

            # Pull and start containers (idempotent)
            echo "🐳 Pulling and starting containers with force-recreate..."
            $COMPOSE pull

            echo "🗄️ Starting MariaDB and Redis..."
            
            # Verify database directory permissions before starting
            echo "🔍 Pre-startup checks..."
            if test -d /var/www/livrolog/shared/db; then
              ls -ld /var/www/livrolog/shared/db
            else
              echo "Database directory not found (will be created)"
            fi
            
            # Start containers with enhanced error reporting
            if ! $COMPOSE up -d --remove-orphans --force-recreate; then
              echo "❌ Failed to start containers"
              echo "=== Docker Compose Status ==="
              $COMPOSE ps || true
              echo "=== Docker System Info ==="
              docker system df || true
              exit 1
            fi
            
            # Immediate status check
            echo "🔍 Initial container status:"
            $COMPOSE ps

            # Wait for MariaDB health with configurable timeout
            # Default: 600s (10 minutes), max: 1800s (30 minutes)
            DB_WAIT_TIMEOUT="${DB_HEALTH_TIMEOUT:-600}"
            [ "$DB_WAIT_TIMEOUT" -gt 1800 ] && DB_WAIT_TIMEOUT=1800

            echo "⏳ Waiting for MariaDB health (timeout=${DB_WAIT_TIMEOUT}s)..."
            deadline=$((SECONDS+DB_WAIT_TIMEOUT))
            while true; do
              if $COMPOSE ps mariadb | grep -q "healthy"; then
                echo "✅ MariaDB is healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "❌ MariaDB health check timed out after ${DB_WAIT_TIMEOUT}s"
                echo "=== MariaDB Status ==="
                $COMPOSE ps mariadb
                echo "=== MariaDB Logs (last 120 lines) ==="
                $COMPOSE logs --tail=120 mariadb
                exit 1
              fi
              
              echo "Waiting for MariaDB... ($((deadline - SECONDS))s remaining)"
              sleep 10
            done

            # Wait for Redis health with configurable timeout  
            # Default: 300s (5 minutes), max: 600s (10 minutes)
            REDIS_WAIT_TIMEOUT="${REDIS_HEALTH_TIMEOUT:-300}"
            [ "$REDIS_WAIT_TIMEOUT" -gt 600 ] && REDIS_WAIT_TIMEOUT=600

            echo "⏳ Waiting for Redis health (timeout=${REDIS_WAIT_TIMEOUT}s)..."
            deadline=$((SECONDS+REDIS_WAIT_TIMEOUT))
            while true; do
              if $COMPOSE ps redis | grep -q "healthy"; then
                echo "✅ Redis is healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "❌ Redis health check timed out after ${REDIS_WAIT_TIMEOUT}s"
                echo "=== Redis Status ==="
                $COMPOSE ps redis
                echo "=== Redis Logs (last 120 lines) ==="
                $COMPOSE logs --tail=120 redis
                exit 1
              fi
              
              echo "Waiting for Redis... ($((deadline - SECONDS))s remaining)"
              sleep 5
            done

            # Optional database seeding (safe and idempotent)
            if [ "$SEED_REQUIRED" -eq 1 ]; then
              echo "🌱 Seeding database from /var/www/livrolog/shared/db-seed.sql..."
              if $COMPOSE exec -T mariadb mysql -u"${DB_USERNAME}" -p"${DB_PASSWORD}" "${DB_DATABASE}" < /var/www/livrolog/shared/db-seed.sql; then
                echo "✅ Database seeded successfully"
              else
                echo "⚠️ Database seeding failed, but continuing with deployment"
              fi
            fi

            # Verify connectivity from API container to MariaDB
            echo "🔍 Verifying API container connectivity..."
            API_CID=$($COMPOSE ps -q api)
            if [ -n "$API_CID" ]; then
              echo "API Container ID: $API_CID"
              echo "Testing MariaDB connectivity from API container:"
              docker exec "$API_CID" timeout 5 bash -c 'cat < /dev/null > /dev/tcp/mariadb/3306' && echo "✅ MariaDB port 3306 reachable from API" || echo "❌ MariaDB port 3306 unreachable from API"
            fi

            # Wait for health checks with timeout
            echo "⏳ Waiting for services to be healthy (max 180s)..."
            deadline=$((SECONDS+180))
            while true; do
              web_ok=0; api_ok=0
              # Check web health
              curl -fsS "http://127.0.0.1:18080/healthz" >/dev/null 2>&1 && web_ok=1
              # Check api health  
              curl -fsS "http://127.0.0.1:18081/health" >/dev/null 2>&1 && api_ok=1
              
              if [ "$web_ok" -eq 1 ] && [ "$api_ok" -eq 1 ]; then 
                echo "✅ All services are healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "❌ Health checks timed out, performing rollback..."
                
                echo "=== Container Status ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
                echo "=== MariaDB Logs (last 80 lines) ==="
                $COMPOSE logs --tail=80 mariadb || true
                echo "=== API Logs (last 80 lines) ==="
                $COMPOSE logs --tail=80 api || true
                echo "=== Web Logs (last 80 lines) ==="
                $COMPOSE logs --tail=80 web || true
                
                echo "=== API->MariaDB connectivity test ==="
                API_CID=$($COMPOSE ps -q api)
                [ -n "$API_CID" ] && docker exec "$API_CID" timeout 5 bash -c 'cat </dev/null >/dev/tcp/mariadb/3306' && echo "✅ API can reach MariaDB" || echo "❌ API cannot reach MariaDB"
                
                # Idempotent rollback (preserve DB volume)
                echo "🔄 Performing idempotent rollback..."
                $COMPOSE down --remove-orphans || true
                LAST_TAG=$(cat .last_tag_prod 2>/dev/null || echo "prod")
                export TAG="$LAST_TAG"
                echo "Rolling back to tag: $TAG"
                $COMPOSE pull
                $COMPOSE up -d --remove-orphans --force-recreate
                exit 1
              fi
              sleep 5
            done

            # Run migrations and clear caches using dynamic container names
            echo "🔄 Rodando migrations..."
            API_CONTAINER=$($COMPOSE ps -q api | head -n 1)
            if [ -z "$API_CONTAINER" ]; then
              echo "❌ No API container found!"
              exit 1
            fi
            docker exec "$API_CONTAINER" php artisan migrate --force

            echo "🧹 Clearing caches..."
            docker exec "$API_CONTAINER" php artisan config:clear || true
            docker exec "$API_CONTAINER" php artisan cache:clear || true
            docker exec "$API_CONTAINER" php artisan config:cache || true
            docker exec "$API_CONTAINER" php artisan route:cache || true

            # Smoke tests
            echo "🧪 Running smoke tests..."
            echo "Testing web frontend:"
            curl -I http://127.0.0.1:18080/ || exit 1
            echo "Testing API health:"
            curl -I http://127.0.0.1:18081/health || exit 1

            # Test database connectivity from API
            echo "Testing database connectivity from API:"
            if docker exec "$API_CONTAINER" php artisan tinker --execute="DB::connection()->getPdo(); echo 'DB OK';" >/dev/null 2>&1; then
              echo "✅ Database connection ok"
            else
              echo "❌ Database connection failed"
              exit 1
            fi

            # Test Redis connectivity
            echo "Testing Redis connectivity:"
            if $COMPOSE exec -T redis redis-cli ping | grep -q "PONG"; then
              echo "✅ Redis connection ok"
            else
              echo "❌ Redis connection failed"
              exit 1
            fi

            echo "✅ All smoke tests passed"
            echo "Container status:"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'

            echo "✅ Production Docker deployment completed successfully!"
            echo "🌐 Web: http://127.0.0.1:18080"
            echo "🔌 API: http://127.0.0.1:18081"
