# yaml-language-server: $schema=
# yamllint disable-file
name: Deploy

on:
  push:
    branches:
      - main
      - dev
    paths:
      - '.github/workflows/deploy.yml'
      - 'api/**'
      - 'webapp/**'
      - 'docker/**'
      - '**/Dockerfile'
  workflow_dispatch:
    inputs:
      branch:
        description: 'Target branch to deploy'
        required: false
        default: 'dev'
        type: choice
        options:
          - 'main'
          - 'dev'

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'
  TARGET_BRANCH: ${{ github.event.inputs.branch || github.ref_name }}

permissions:
  contents: read
  packages: write
  attestations: write
  id-token: write

jobs:
  required-checks:
    uses: ./.github/workflows/required-checks.yml

  build:
    needs: required-checks
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
    secrets: inherit

  # Legacy deploy job (disabled - Docker containers handle deployment now)
  # deploy:
  #   name: deploy
  #   runs-on: ubuntu-latest
  #   needs: [required-checks, build]
  #   if: false  # Disabled in favor of Docker containers

  # post-deploy:
  #   name: post-deploy
  #   needs: [deploy]
  #   uses: ./.github/workflows/post-deploy.yml
  #   with:
  #     environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
  #   secrets: inherit

  # Legacy rollback (disabled - Docker containers handle rollback now)

  # Production deployment via Docker containers
  docker-canary-prod:
    name: docker-canary-prod
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'main'))

    env:
      ENVIRONMENT: Production
      TARGET_BRANCH: main
      DEPLOY_PATH: /var/www/livrolog
      GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
      GITHUB_SHA: ${{ github.sha }}
      GITHUB_REF_NAME: ${{ github.ref_name }}

    steps:
      - name: Checkout code for compose file
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate required secrets
        run: |
          echo "üîç Validating required secrets and environment variables..."

          # Check required secrets
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå SERVER_HOST secret is not configured"
            exit 1
          fi

          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            echo "‚ùå SERVER_USER secret is not configured" 
            exit 1
          fi

          if [ -z "${{ secrets.SERVER_SSH_KEY }}" ]; then
            echo "‚ùå SERVER_SSH_KEY secret is not configured"
            exit 1
          fi

          # APP_KEY is required for production
          if [ -z "${{ secrets.APP_KEY }}" ]; then
            echo "‚ùå APP_KEY secret is not configured for production"
            exit 1
          fi

          # DB_PASSWORD is required for production
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "‚ùå DB_PASSWORD secret is not configured for production"
            exit 1
          fi

          # GHCR_PAT is optional for public images, but warn if missing
          if [ -z "${{ secrets.GHCR_PAT }}" ]; then
            echo "‚ö†Ô∏è GHCR_PAT secret not found - will attempt to pull public images"
          fi

          echo "‚úÖ Secret validation completed"

      - name: Setup SSH key and test connection
        run: |
          echo "üîê Setting up SSH connection..."

          # Create SSH directory and set permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Create SSH private key file
          echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/livrolog_key
          chmod 600 ~/.ssh/livrolog_key

          # Disable host key checking for this deployment (AWS instances change IPs)
          echo "Host ${{ secrets.SERVER_HOST }}" >> ~/.ssh/config
          echo "  HostName ${{ secrets.SERVER_HOST }}" >> ~/.ssh/config
          echo "  User ${{ secrets.SERVER_USER }}" >> ~/.ssh/config
          echo "  IdentityFile ~/.ssh/livrolog_key" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          echo "  LogLevel QUIET" >> ~/.ssh/config
          chmod 600 ~/.ssh/config

          # Test SSH connection
          echo "üîç Testing SSH connection to ${{ secrets.SERVER_HOST }}..."
          if ssh ${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connection test passed"
          else
            echo "‚ùå SSH connection test failed"
            echo "Debug information:"
            echo "  Host: ${{ secrets.SERVER_HOST }}"
            echo "  User: ${{ secrets.SERVER_USER }}"
            echo "  Key length: ${#{{ secrets.SERVER_SSH_KEY }}}"
            exit 1
          fi

      - name: Create production .env file
        run: |
          echo "üìù Creating production .env file locally..."
          cat > .env.prod << EOF
          APP_NAME=LivroLog
          APP_ENV=production
          APP_KEY=${{ secrets.APP_KEY }}
          APP_DEBUG=false
          APP_TIMEZONE=UTC

          DB_CONNECTION=mysql
          DB_HOST=mariadb
          DB_PORT=3306
          DB_DATABASE=livrolog
          DB_USERNAME=${{ secrets.DB_USERNAME || 'root' }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}

          REDIS_CLIENT=predis
          REDIS_HOST=redis
          REDIS_PASSWORD=null
          REDIS_PORT=6379

          QUEUE_CONNECTION=redis
          SESSION_DRIVER=redis
          SESSION_LIFETIME=120
          CACHE_DRIVER=redis
          MAIL_MAILER=resend
          MAIL_FROM_ADDRESS=noreply@livrolog.com
          MAIL_FROM_NAME=\${APP_NAME}
          LOG_CHANNEL=stack
          LOG_LEVEL=error

          RESEND_KEY=${{ secrets.RESEND_KEY }}

          GOOGLE_BOOKS_API_KEY=${{ secrets.GOOGLE_BOOKS_API_KEY }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          AMAZON_PA_API_KEY=${{ secrets.AMAZON_PA_API_KEY }}
          AMAZON_PA_SECRET_KEY=${{ secrets.AMAZON_PA_SECRET_KEY }}
          AMAZON_ASSOCIATE_TAG=${{ secrets.AMAZON_ASSOCIATE_TAG }}
          AMAZON_SITESTRIPE_ENABLED=${{ secrets.AMAZON_SITESTRIPE_ENABLED }}
          EOF

          echo "‚úÖ Production .env file created locally"

      - name: Copy compose file and env to server
        run: |
          echo "üìÅ Copying files to server..."

          # Create target directory on server
          ssh ${{ secrets.SERVER_HOST }} "sudo mkdir -p ${DEPLOY_PATH}/docker ${DEPLOY_PATH}/shared && sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} ${DEPLOY_PATH}"

          # Copy compose file
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.SERVER_HOST }}:${DEPLOY_PATH}/docker/

          # Copy .env file
          scp -o StrictHostKeyChecking=no .env.prod ${{ secrets.SERVER_HOST }}:${DEPLOY_PATH}/shared/

          # Copy backup scripts
          scp -o StrictHostKeyChecking=no scripts/backup_database.sh ${{ secrets.SERVER_HOST }}:/home/bitnami/
          scp -o StrictHostKeyChecking=no scripts/setup_backup_cron.sh ${{ secrets.SERVER_HOST }}:/home/bitnami/
          ssh ${{ secrets.SERVER_HOST }} "chmod +x /home/bitnami/*.sh"

          echo "‚úÖ Files copied successfully"

      - name: Deploy production containers
        run: |
          ssh ${{ secrets.SERVER_HOST }} "bash -s" << 'DEPLOY_SCRIPT'
            set -euo pipefail
            # Configuration
            DOCKER_DIR="${{ env.DEPLOY_PATH }}/docker"
            SHARED_DIR="${{ env.DEPLOY_PATH }}/shared"
            OWNER="${{ env.GITHUB_REPOSITORY_OWNER }}"
            TAG="prod"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            echo "=================================================="
            echo "üöÄ LivroLog Production Deployment"
            echo "Branch: ${{ env.TARGET_BRANCH }}"
            echo "SHA: ${{ env.GITHUB_SHA }}"
            echo "Images: ${IMAGE_API}:${TAG}, ${IMAGE_WEB}:${TAG}"
            echo "Deploy Path: ${{ env.DEPLOY_PATH }}"
            echo "=================================================="

            # Create required directories with proper permissions
            echo "üìÅ Setting up directories and permissions..."
            sudo mkdir -p "${SHARED_DIR}"/{storage,db}
            sudo mkdir -p "${DOCKER_DIR}"

            # Set MariaDB data directory permissions (UID 999)
            sudo chown -R 999:999 "${SHARED_DIR}/db"

            # Set Laravel storage permissions (www-data)
            sudo chown -R www-data:www-data "${SHARED_DIR}/storage" 2>/dev/null || sudo chown -R 82:82 "${SHARED_DIR}/storage"

            # Set deployment directory permissions
            sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} "${{ env.DEPLOY_PATH }}"

            # Navigate to docker directory
            cd "${DOCKER_DIR}"

            # Login to GitHub Container Registry if PAT available
            if [ -n "${{ secrets.GHCR_PAT }}" ]; then
              echo "üîê Authenticating with GitHub Container Registry..."
              echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u "${{ env.GITHUB_REPOSITORY_OWNER }}" --password-stdin
            else
              echo "‚ö†Ô∏è No GHCR_PAT provided - attempting to pull public images"
            fi

            # Pull latest images with error handling
            echo "üì¶ Pulling latest Docker images..."

            # Force pull latest images using compose first
            docker compose -f docker-compose.prod.yml pull || echo "‚ö†Ô∏è Compose pull failed, trying individual pulls"

            if ! docker pull "${IMAGE_API}:${TAG}"; then
              echo "‚ö†Ô∏è Failed to pull API image ${IMAGE_API}:${TAG}"
              echo "Available API tags:"
              docker images | grep livrolog-api || echo "No local API images found"
            fi

            if ! docker pull "${IMAGE_WEB}:${TAG}"; then
              echo "‚ö†Ô∏è Failed to pull Web image ${IMAGE_WEB}:${TAG}"
              echo "Available Web tags:"
              docker images | grep livrolog-web || echo "No local Web images found"
            fi

            # Clean up old images to force using new ones
            echo "üßπ Cleaning up old images..."
            docker image prune -f --filter "label=org.opencontainers.image.source=https://github.com/arnonrdp/LivroLog" || true

            # Stop existing containers gracefully
            echo "üõë Stopping existing production containers..."
            if docker compose -f docker-compose.prod.yml ps --services --filter "status=running" | grep -q .; then
              docker compose -f docker-compose.prod.yml down --timeout 30
              echo "‚úÖ Existing containers stopped"
            else
              echo "‚ÑπÔ∏è No running containers to stop"
            fi
            
            # Clean up orphaned containers and networks
            echo "üßπ Cleaning up orphaned resources..."
            docker container prune -f --filter "label=com.docker.compose.project=livrolog" || true
            docker network prune -f || true
            
            # Export environment variables for docker-compose
            export GITHUB_REPOSITORY_OWNER="${OWNER}"
            export TAG="${TAG}"
            export DB_DATABASE="livrolog"
            export DB_USERNAME="${{ secrets.DB_USERNAME || 'root' }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            
            # Start containers with health checks
            echo "üöÄ Starting production containers..."
            if ! docker compose -f docker-compose.prod.yml up -d --remove-orphans; then
              echo "‚ùå Failed to start containers"
              echo "=== Docker Compose Logs ==="
              docker compose -f docker-compose.prod.yml logs --tail=50
              exit 1
            fi
            
            echo "‚úÖ Containers started successfully"
            
            # Wait for containers to initialize
            echo "‚è≥ Waiting for containers to initialize (90 seconds)..."
            sleep 90
            
            # Health checks with detailed status
            echo "üîç Performing health checks..."
            
            # Check container status
            echo "üìä Container Status:"
            docker compose -f docker-compose.prod.yml ps
            
            # Check MariaDB connectivity
            echo "üîç Testing MariaDB connectivity..."
            for i in {1..18}; do
              if docker exec livrolog-mariadb-1 mysqladmin ping -u root -p${{ secrets.DB_PASSWORD }} --silent 2>/dev/null; then
                echo "‚úÖ MariaDB is responding (attempt $i)"
                break
              elif [ $i -eq 18 ]; then
                echo "‚ùå MariaDB health check failed after 18 attempts"
                docker logs livrolog-mariadb-1 --tail=30
                exit 1
              else
                echo "‚è≥ MariaDB not ready yet (attempt $i/18), waiting 10 seconds..."
                sleep 10
              fi
            done
            
            # Check Redis connectivity  
            echo "üîç Testing Redis connectivity..."
            if docker exec livrolog-redis-1 redis-cli ping >/dev/null 2>&1; then
              echo "‚úÖ Redis is responding"
            else
              echo "‚ùå Redis health check failed"
              docker logs livrolog-redis-1 --tail=20
              exit 1
            fi
            
            # Check API health endpoint
            echo "üîç Testing API health endpoint..."
            for i in {1..30}; do  
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:18081/healthz 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ API health endpoint responding (HTTP $HTTP_CODE)"
                break
              elif [ $i -eq 30 ]; then
                echo "‚ùå API health endpoint failed after 30 attempts (HTTP $HTTP_CODE)"
                echo "=== API Container Logs ==="
                docker logs livrolog-api-1 --tail=50
                exit 1
              else
                echo "‚è≥ API not ready yet (HTTP $HTTP_CODE, attempt $i/30), waiting 10 seconds..."
                sleep 10
              fi
            done
            
            # Check Web frontend
            echo "üîç Testing Web frontend..."  
            for i in {1..18}; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:18080/ 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ Web frontend responding (HTTP $HTTP_CODE)"
                break
              elif [ $i -eq 18 ]; then
                echo "‚ùå Web frontend failed after 18 attempts (HTTP $HTTP_CODE)"
                echo "=== Web Container Logs ==="
                docker logs livrolog-web-1 --tail=30
                exit 1
              else
                echo "‚è≥ Web not ready yet (HTTP $HTTP_CODE, attempt $i/18), waiting 5 seconds..."
                sleep 5
              fi
            done
            
            # Run Laravel migrations and optimizations
            echo "üîÑ Running Laravel migrations and optimizations..."
            API_CONTAINER=$(docker compose -f docker-compose.prod.yml ps -q api)
            if [ -n "$API_CONTAINER" ]; then
              docker exec "$API_CONTAINER" php artisan migrate --force
              docker exec "$API_CONTAINER" php artisan config:cache
              docker exec "$API_CONTAINER" php artisan route:cache
              # Skip view:cache - API doesn't have views
              echo "‚úÖ Laravel optimizations completed"
            else
              echo "‚ö†Ô∏è API container not found for Laravel commands"
            fi
            
            echo "=================================================="
            echo "üéâ Production deployment completed successfully!"
            echo "üìç Services:"
            echo "  ‚Ä¢ Web Frontend: https://livrolog.com"
            echo "  ‚Ä¢ API Backend: https://api.livrolog.com"
            echo "  ‚Ä¢ Internal Web: http://127.0.0.1:18080"
            echo "  ‚Ä¢ Internal API: http://127.0.0.1:18081"
            echo "=================================================="
            
          DEPLOY_SCRIPT

      - name: Setup backup automation
        run: |
          echo "‚öôÔ∏è Setting up backup automation for production..."
          ssh ${{ secrets.SERVER_HOST }} "/home/bitnami/setup_backup_cron.sh"

      - name: Post-deployment verification
        run: |
          echo "üîç Running post-deployment verification..."

          # Final connectivity tests
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:18081/healthz || echo "FAIL")
          WEB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:18080/ || echo "FAIL")

          echo "Final Status Check:"
          echo "  API Health: $API_STATUS"
          echo "  Web Status: $WEB_STATUS"

          if [ "$API_STATUS" = "200" ] && [ "$WEB_STATUS" = "200" ]; then
            echo "‚úÖ All services are healthy and accessible"
          else
            echo "‚ö†Ô∏è Some services may not be fully ready yet"
            echo "This is normal for large applications and they should be ready shortly"
          fi

          echo "üéØ Production deployment verification completed"
