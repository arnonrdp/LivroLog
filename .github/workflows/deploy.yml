name: Deploy

on:
  push:
    branches:
      - main
      - dev
    paths:
      - '.github/workflows/deploy.yml'
      - 'api/**'
      - 'webapp/**'
      - 'docker/**'
      - '**/Dockerfile'
  workflow_dispatch:
    inputs:
      branch:
        description: 'Target branch to deploy'
        required: false
        default: ''
        type: choice
        options:
          - 'main'
          - 'dev'

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'
  TARGET_BRANCH: ${{ github.event.inputs.branch || github.ref_name }}

permissions:
  contents: read
  packages: write
  attestations: write
  id-token: write

jobs:
  required-checks:
    uses: ./.github/workflows/required-checks.yml

  build:
    needs: required-checks
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
    secrets: inherit

  # Legacy deploy job (disabled - Docker containers handle deployment now)
  # deploy:
  #   name: deploy
  #   runs-on: ubuntu-latest
  #   needs: [required-checks, build]
  #   if: false  # Disabled in favor of Docker containers

  # post-deploy:
  #   name: post-deploy
  #   needs: [deploy]
  #   uses: ./.github/workflows/post-deploy.yml
  #   with:
  #     environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
  #   secrets: inherit

  # Legacy rollback (disabled - Docker containers handle rollback now)

  # Docker container deployments are the primary deployment method
  docker-canary-dev:
    name: docker-canary-dev
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/dev' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'dev'))

    env:
      ENVIRONMENT: Development
      DEPLOY_PATH: /var/www/livrolog-dev
      GHCR_PAT: ${{ secrets.GHCR_PAT }}
      TARGET_BRANCH: dev

    steps:
      - name: Deploy canary containers (livrolog-dev)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_PAT,GITHUB_SHA,GITHUB_REF_NAME,TARGET_BRANCH
          script: |
            set -euo pipefail +x
            DOCKER_DIR="/var/www/livrolog-dev/docker"
            OWNER="arnonrdp"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            sudo mkdir -p "$DOCKER_DIR"
            sudo chown -R bitnami:bitnami /var/www/livrolog-dev
            cd "$DOCKER_DIR"

            # Login condicional no GHCR (se GHCR_PAT estiver definido e n√£o vazio)
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u arnonrdp --password-stdin
            else
              echo "Aviso: GHCR_PAT vazio. Se os pacotes forem privados, o pull falhar√°."
            fi

            # Encontrar porta livre entre 8082-8090
            WEB_PORT=""
            for port in {8082..8090}; do
              if ! ss -ltn | grep -q ":${port} "; then
                WEB_PORT=$port
                break
              fi
            done

            if [ -z "$WEB_PORT" ]; then
              echo "‚ùå Nenhuma porta dispon√≠vel entre 8082-8090. Verifique processos em execu√ß√£o." >&2
              exit 1
            fi

            echo "üîç Usando porta ${WEB_PORT} para web"

            # Limpar containers antigos do LivroLog e espa√ßo em disco
            docker rm -f livrolog-web-dev livrolog-web 2>/dev/null || true

            # Limpeza seletiva de espa√ßo em disco (r√°pida e eficiente)
            echo "üßπ Limpando recursos Docker n√£o utilizados..."
            # Remove apenas containers parados e volumes √≥rf√£os (r√°pido)
            timeout 10 docker system prune -f --volumes 2>/dev/null || true
            # Skip image pruning for dev - not critical
            echo "‚úÖ Limpeza conclu√≠da"

            # Gera compose dev
            cat > docker-compose.dev.yml << EOF
            name: livrolog_dev
            services:
              web:
                image: REPLACE_WEB_IMAGE
                container_name: livrolog-web-dev
                restart: always
                ports:
                  - "${WEB_PORT}:80"
                healthcheck:
                  test: ["CMD", "curl", "-fsS", "http://localhost/healthz"]
                  interval: 15s
                  timeout: 3s
                  retries: 10
                depends_on:
                  - api
              api:
                image: REPLACE_API_IMAGE
                container_name: livrolog-api-dev
                restart: always
                env_file:
                  - /var/www/livrolog-dev/shared/.env.dev
                environment:
                  - DB_HOST=127.0.0.1
                  - DB_PORT=3306
                  - REDIS_HOST=127.0.0.1
                  - REDIS_PORT=6379
                network_mode: host
                volumes:
                  - /var/www/livrolog-dev/shared/storage:/var/www/html/storage
                healthcheck:
                  test: ["CMD", "php", "artisan", "about"]
                  interval: 10s
                  timeout: 5s
                  retries: 30
                  start_period: 60s
            EOF

            # Ler tag anterior para rollback real em caso de falha
            PREV_TAG=$(cat .last_tag_dev 2>/dev/null || echo "dev")
            echo "üìã Tag anterior para rollback: ${PREV_TAG}"

            # Resolve tag existente: dev-<sha> -> <sha> -> dev
            BRANCH="${TARGET_BRANCH:-${GITHUB_REF_NAME:-dev}}"
            SHA="${GITHUB_SHA}"
            CANDIDATES=("${BRANCH}-${SHA}" "${SHA}" "${BRANCH}")

            RESOLVED_TAG=""
            for tag in "${CANDIDATES[@]}"; do
              if docker manifest inspect "${IMAGE_WEB}:${tag}" >/dev/null 2>&1 && docker manifest inspect "${IMAGE_API}:${tag}" >/dev/null 2>&1; then
                RESOLVED_TAG="${tag}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "‚ùå Nenhuma tag encontrada (testadas: ${CANDIDATES[*]}). Verifique as tags publicadas no GHCR." >&2
              exit 1
            fi

            echo "$RESOLVED_TAG" > .resolved_tag_dev
            export TAG="$RESOLVED_TAG"

            # Define compose command para dev
            # Centraliza flags comuns para opera√ß√µes do docker compose dev
            COMPOSE="docker compose -p livrolog_dev -f docker-compose.dev.yml"
            echo "üìã Using compose command: $COMPOSE"

            # Substitui as imagens no compose
            sed -i "s|REPLACE_WEB_IMAGE|${IMAGE_WEB}:${TAG}|g" docker-compose.dev.yml
            sed -i "s|REPLACE_API_IMAGE|${IMAGE_API}:${TAG}|g" docker-compose.dev.yml

            # Setup APP_KEY for development environment (same logic as production)
            echo "üîß Setting up APP_KEY for development environment..."

            # Fun√ß√£o POSIX para gerar APP_KEY compat√≠vel com Laravel (sem depender de imagens externas)
            gen_app_key() {
              if command -v head >/dev/null 2>&1 && command -v base64 >/dev/null 2>&1; then
                head -c 32 /dev/urandom | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              elif command -v openssl >/dev/null 2>&1; then
                openssl rand -base64 32 | tr -d '\n' | awk '{print "base64:" $0}'
              else
                echo ""
              fi
            }

            # Use the same gen_app_key function and pattern as production
            APP_KEY_PATTERN='^base64:[A-Za-z0-9+/=]{44}$'
            APP_KEY_CAND="${APP_KEY:-}"
            echo "üîç Validating APP_KEY candidate for dev: [${#APP_KEY_CAND} chars]${APP_KEY_CAND:+ (has value)}${APP_KEY_CAND:- (empty)}"

            # Validate APP_KEY format: base64:44characters
            if ! printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN"; then
              echo "‚ö†Ô∏è APP_KEY secret ausente/inv√°lido; gerando automaticamente para dev..."
              APP_KEY_CAND="$(gen_app_key || true)"
            fi
            echo "üîß APP_KEY for dev: [${#APP_KEY_CAND} chars]${APP_KEY_CAND:+ ($(printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN" && echo "valid" || echo "invalid"))}${APP_KEY_CAND:- (empty)}"

            # Setup .env.dev file with proper APP_KEY
            if printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN"; then
              # Ensure the dev shared directory and storage exist
              sudo mkdir -p /var/www/livrolog-dev/shared
              sudo mkdir -p /var/www/livrolog-dev/shared/storage
              sudo chown -R bitnami:bitnami /var/www/livrolog-dev
              
              # Create/update the .env.dev file with APP_KEY
              tmpfile="$(mktemp)"
              # If .env.dev exists, remove any existing APP_KEY line
              if [ -f /var/www/livrolog-dev/shared/.env.dev ]; then
                grep -v '^APP_KEY=' /var/www/livrolog-dev/shared/.env.dev > "$tmpfile" || true
              fi
              # Add the valid APP_KEY
              printf 'APP_KEY=%s\n' "$APP_KEY_CAND" >> "$tmpfile"
              # Add basic Laravel environment settings if .env.dev didn't exist
              if [ ! -f /var/www/livrolog-dev/shared/.env.dev ]; then
                {
                  echo "APP_NAME=LivroLog"
                  echo "APP_ENV=production"
                  echo "APP_DEBUG=false"
                  echo "APP_URL=http://localhost"
                  echo ""
                  echo "LOG_CHANNEL=stack"
                  echo "LOG_DEPRECATIONS_CHANNEL=null"
                  echo "LOG_LEVEL=debug"
                  echo ""
                  echo "DB_CONNECTION=mysql"
                  echo "DB_HOST=127.0.0.1"
                  echo "DB_PORT=3306"
                  echo "DB_DATABASE=livrolog"
                  echo "DB_USERNAME=livrolog"
                  echo "DB_PASSWORD="
                  echo ""
                  echo "BROADCAST_DRIVER=log"
                  echo "CACHE_DRIVER=redis"
                  echo "FILESYSTEM_DISK=local"
                  echo "QUEUE_CONNECTION=sync"
                  echo "SESSION_DRIVER=file"
                  echo "SESSION_LIFETIME=120"
                  echo ""
                  echo "REDIS_HOST=127.0.0.1"
                  echo "REDIS_PASSWORD=null"
                  echo "REDIS_PORT=6379"
                } >> "$tmpfile"
              fi
              sudo mv "$tmpfile" /var/www/livrolog-dev/shared/.env.dev
              sudo chown bitnami:bitnami /var/www/livrolog-dev/shared/.env.dev
              echo "‚úÖ APP_KEY provisionada/atualizada em /var/www/livrolog-dev/shared/.env.dev"
            else
              echo "‚ùå Falha ao provisionar APP_KEY automaticamente para dev (n√£o foi poss√≠vel obter uma chave v√°lida)"
              exit 1
            fi

            # Verificar .env e storage antes do up (fail-fast com mensagem clara)
            test -f /var/www/livrolog-dev/shared/.env.dev || { echo "‚ùå /var/www/livrolog-dev/shared/.env.dev n√£o existe"; exit 1; }
            test -d /var/www/livrolog-dev/shared/storage || { echo "‚ùå /var/www/livrolog-dev/shared/storage n√£o existe"; exit 1; }

            # Persistir porta escolhida para debug
            echo "$WEB_PORT" > .web_port_dev

            # Pull e start
            $COMPOSE pull
            $COMPOSE up -d --remove-orphans

            # Espera healthchecks (aumentado timeout para 180s)
            echo "Waiting for services to be healthy (max 180s)‚Ä¶"
            deadline=$((SECONDS+180))
            while true; do
              web_ok=0; api_ok=0
              curl -fsS "http://localhost:${WEB_PORT}/healthz" >/dev/null 2>&1 && web_ok=1
              docker exec livrolog-api-dev php artisan about >/dev/null 2>&1 && api_ok=1
              if [ "$web_ok" -eq 1 ] && [ "$api_ok" -eq 1 ]; then break; fi
              if [ $SECONDS -ge $deadline ]; then
                echo "‚ùå Health checks failed, rolling back para tag anterior‚Ä¶"
                echo "=== Diagn√≥stico de containers ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
                echo "=== Health status da API ==="
                if command -v jq >/dev/null 2>&1; then
                  docker inspect --format='{{json .State.Health}}' livrolog-api-dev | jq . || true
                else
                  echo "‚ö†Ô∏è jq n√£o encontrado, exibindo JSON raw:"
                  docker inspect --format='{{json .State.Health}}' livrolog-api-dev || true
                fi
                echo "=== Logs da API (√∫ltimas 80 linhas) ==="
                docker logs --tail=80 livrolog-api-dev || true
                echo "=== Logs da Web (√∫ltimas 80 linhas) ==="
                docker logs --tail=80 livrolog-web-dev || true
                echo "=== Iniciando rollback para tag: ${PREV_TAG} ==="
                export TAG="$PREV_TAG"
                sed -i "s|ghcr.io/.*/livrolog-web:.*|${IMAGE_WEB}:${TAG}|g" docker-compose.dev.yml
                sed -i "s|ghcr.io/.*/livrolog-api:.*|${IMAGE_API}:${TAG}|g" docker-compose.dev.yml
                $COMPOSE pull
                $COMPOSE up -d --remove-orphans
                exit 1
              fi
              sleep 5
            done

            # Migrations e caches
            docker exec livrolog-api-dev php artisan migrate --force
            docker exec livrolog-api-dev php artisan config:clear || true
            docker exec livrolog-api-dev php artisan cache:clear || true

            # Deploy bem-sucedido: atualizar .last_tag_dev para pr√≥ximos rollbacks
            echo "$RESOLVED_TAG" > .last_tag_dev
            echo "üìù Tag $RESOLVED_TAG salva para rollbacks futuros"

            echo "‚úÖ Canary OK em http://$(hostname -I | awk '{print $1}'):${WEB_PORT}"
            echo "üéØ Deployed branch: ${TARGET_BRANCH:-dev}"

  docker-canary-prod:
    name: docker-canary-prod
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'main'))

    env:
      ENVIRONMENT: Production
      DEPLOY_PATH: /var/www/livrolog
      GHCR_PAT: ${{ secrets.GHCR_PAT }}
      APP_KEY: ${{ secrets.APP_KEY }}
      DEPLOY_DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      DB_HEALTH_TIMEOUT: ${{ secrets.DB_HEALTH_TIMEOUT || 300 }}
      REDIS_HEALTH_TIMEOUT: '180'
      TARGET_BRANCH: main

    steps:
      - name: Checkout code for compose file
        uses: actions/checkout@v4

      - name: Deploy production containers
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_PAT,GITHUB_SHA,GITHUB_REF_NAME,APP_KEY,DEPLOY_DB_PASSWORD,DB_HEALTH_TIMEOUT,REDIS_HEALTH_TIMEOUT,TARGET_BRANCH
          command_timeout: 15m
          script: |
            set -euo pipefail +x
            DOCKER_DIR="/var/www/livrolog/docker"
            OWNER="arnonrdp"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            # Display deployment configuration
            echo "=================================================="
            echo "üöÄ Starting production deployment (branch: ${TARGET_BRANCH:-main})"
            echo "Using internal MariaDB + Redis containers"
            echo "DB_HEALTH_TIMEOUT=${DB_HEALTH_TIMEOUT:-600}s, REDIS_HEALTH_TIMEOUT=${REDIS_HEALTH_TIMEOUT:-300}s"
            echo "Deployment is idempotent - auto-normalizes .env configuration"
            echo "=================================================="

            # Create all required directories
            echo "üìÅ Creating required directories..."
            sudo mkdir -p "$DOCKER_DIR"
            sudo mkdir -p /var/www/livrolog/shared/{storage,db}

            # Set proper permissions (999:999 is the default MariaDB container user)
            sudo chown -R 999:999 /var/www/livrolog/shared/db
            sudo chown -R "$USER:$USER" /var/www/livrolog
            cd "$DOCKER_DIR"

            # Auto-provision and normalize .env (idempotent)
            echo "üîß Normalizing .env configuration..."
            sudo touch /var/www/livrolog/shared/.env
            sudo chown -R "$USER:$USER" /var/www/livrolog/shared/.env

            # Fun√ß√£o POSIX para gerar APP_KEY compat√≠vel com Laravel (sem depender de imagens externas)
            gen_app_key() {
              if command -v head >/dev/null 2>&1 && command -v base64 >/dev/null 2>&1; then
                head -c 32 /dev/urandom | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              elif command -v openssl >/dev/null 2>&1; then
                openssl rand -base64 32 | tr -d '\n' | awk '{print "base64:" $0}'
              else
                dd if=/dev/urandom bs=32 count=1 2>/dev/null | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              fi
            }

            # Define APP_KEY validation pattern to avoid YAML truncation issues
            APP_KEY_PATTERN='^base64:[A-Za-z0-9+/=]{44}$'

            # Auto-provision APP_KEY if needed
            APP_KEY_CAND="${APP_KEY:-}"
            if ! printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN"; then
              echo "‚ö†Ô∏è APP_KEY secret ausente/inv√°lido; gerando automaticamente..."
              APP_KEY_CAND="$(gen_app_key || true)"
            fi
            echo "üîß APP_KEY for prod: [${#APP_KEY_CAND} chars]${APP_KEY_CAND:+ ($(printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN" && echo "valid" || echo "invalid"))}${APP_KEY_CAND:- (empty)}"

            # Save valid APP_KEY to .env
            if printf '%s' "$APP_KEY_CAND" | grep -Eq "$APP_KEY_PATTERN"; then
              tmpfile="$(mktemp)"
              grep -v '^APP_KEY=' /var/www/livrolog/shared/.env > "$tmpfile" || true
              printf 'APP_KEY=%s\n' "$APP_KEY_CAND" >> "$tmpfile"
              mv "$tmpfile" /var/www/livrolog/shared/.env
              echo "‚úÖ APP_KEY provisionada/atualizada em /var/www/livrolog/shared/.env"
            else
              echo "‚ùå Falha ao provisionar APP_KEY automaticamente"
              exit 1
            fi

            # Normalize database and Redis configuration (idempotent)
            # This step ensures the .env always has correct values for internal services
            # regardless of previous state, making the deployment fully idempotent
            echo "üìù Normalizing database and Redis configuration in .env..."

            # Read existing values to preserve from .env file
            eval $(grep -E '^(DB_DATABASE|DB_USERNAME|DB_PASSWORD)=' /var/www/livrolog/shared/.env 2>/dev/null || true)

            # Bootstrap database credentials from GitHub Secrets if not present in .env
            [ -z "${DB_DATABASE:-}" ] && DB_DATABASE="livrolog" && echo "üìù Using default DB_DATABASE: ${DB_DATABASE}"
            [ -z "${DB_USERNAME:-}" ] && DB_USERNAME="root" && echo "üìù Using default DB_USERNAME: ${DB_USERNAME}"

            # Bootstrap DB_PASSWORD - prioridade: .env -> GitHub Secret -> falha
            DB_PASSWORD_FROM_ENV="${DB_PASSWORD:-}"
            DEPLOY_DB_PASSWORD="${DEPLOY_DB_PASSWORD:-}"

            if [ -n "${DB_PASSWORD_FROM_ENV}" ]; then
              DB_PASSWORD="${DB_PASSWORD_FROM_ENV}"
              echo "üìù Using DB_PASSWORD from existing .env file"
            elif [ -n "${DEPLOY_DB_PASSWORD}" ]; then
              DB_PASSWORD="${DEPLOY_DB_PASSWORD}"
              echo "üìù Bootstrapping DB_PASSWORD from GitHub Secret"
            else
              echo "‚ùå DB_PASSWORD not found in .env and DEPLOY_DB_PASSWORD secret not provided"
              exit 1
            fi

            # Create normalized .env with correct values (atomic operation)
            tmpfile="$(mktemp)"

            # Copy all non-DB/Redis lines
            grep -v -E '^(APP_ENV|DB_CONNECTION|DB_HOST|DB_PORT|DB_DATABASE|DB_USERNAME|DB_PASSWORD|REDIS_HOST|REDIS_PORT)=' /var/www/livrolog/shared/.env > "$tmpfile" 2>/dev/null || true

            # Append normalized configuration
            cat >> "$tmpfile" << ENVEOF
            APP_ENV=production
            DB_CONNECTION=mysql
            DB_HOST=mariadb
            DB_PORT=3306
            DB_DATABASE=${DB_DATABASE}
            DB_USERNAME=${DB_USERNAME}
            DB_PASSWORD=${DB_PASSWORD}
            REDIS_HOST=redis
            REDIS_PORT=6379
            ENVEOF

            # Atomically replace .env
            mv "$tmpfile" /var/www/livrolog/shared/.env
            echo "‚úÖ .env normalized for internal MariaDB and Redis"

            # Pre-checks: verify environment and infrastructure
            echo "üîç Performing pre-deployment checks..."

            # Check 1: required directories exist
            test -f /var/www/livrolog/shared/.env || { echo "‚ùå /var/www/livrolog/shared/.env n√£o existe"; exit 1; }
            test -d /var/www/livrolog/shared/storage || { echo "‚ùå /var/www/livrolog/shared/storage n√£o existe"; exit 1; }
            test -d /var/www/livrolog/shared/db || { echo "‚ùå /var/www/livrolog/shared/db n√£o existe"; exit 1; }

            # Validate APP_KEY in .env file
            echo "üîç Validating APP_KEY in .env file..."
            ENV_APP_KEY=$(grep '^APP_KEY=' /var/www/livrolog/shared/.env 2>/dev/null | cut -d'=' -f2- && true || echo "")
            if ! printf '%s' "$ENV_APP_KEY" | grep -Eq "$APP_KEY_PATTERN"; then
              echo "‚ùå APP_KEY inv√°lido/ausente em /var/www/livrolog/shared/.env"
              exit 1
            fi
            echo "‚úÖ APP_KEY validation passed"

            # Reload normalized values for validation
            eval $(grep -E '^(DB_CONNECTION|DB_HOST|DB_PORT|DB_DATABASE|DB_USERNAME|DB_PASSWORD|REDIS_HOST|REDIS_PORT)=' /var/www/livrolog/shared/.env)

            # Validate critical configuration
            echo "Validating normalized configuration..."
            [ "${DB_CONNECTION}" = "mysql" ] || { echo "‚ùå DB_CONNECTION validation failed"; exit 1; }
            [ "${DB_HOST}" = "mariadb" ] || { echo "‚ùå DB_HOST validation failed"; exit 1; }
            [ "${DB_PORT}" = "3306" ] || { echo "‚ùå DB_PORT validation failed"; exit 1; }
            [ "${REDIS_HOST}" = "redis" ] || { echo "‚ùå REDIS_HOST validation failed"; exit 1; }
            [ "${REDIS_PORT}" = "6379" ] || { echo "‚ùå REDIS_PORT validation failed"; exit 1; }
            [ -n "${DB_DATABASE}" ] || { echo "‚ùå DB_DATABASE is empty"; exit 1; }
            [ -n "${DB_USERNAME}" ] || { echo "‚ùå DB_USERNAME is empty"; exit 1; }
            [ -n "${DB_PASSWORD}" ] || { echo "‚ùå DB_PASSWORD is empty"; exit 1; }

            echo "‚úÖ Configuration validated successfully"

            # Login to GHCR if PAT is available
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u arnonrdp --password-stdin
            else
              echo "‚ö†Ô∏è GHCR_PAT not set. Using public access."
            fi

            # Resolve tag: prefer 'prod', fallback to SHA
            BRANCH="${TARGET_BRANCH:-${GITHUB_REF_NAME:-main}}"
            SHA="${GITHUB_SHA}"
            CANDIDATES=("prod" "${SHA}" "${BRANCH}")

            RESOLVED_TAG=""
            for tag in "${CANDIDATES[@]}"; do
              if docker manifest inspect "${IMAGE_WEB}:${tag}" >/dev/null 2>&1 && docker manifest inspect "${IMAGE_API}:${tag}" >/dev/null 2>&1; then
                RESOLVED_TAG="${tag}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "‚ùå Nenhuma tag encontrada (testadas: ${CANDIDATES[*]})"
              exit 1
            fi

            echo "üè∑Ô∏è Using resolved tag: $RESOLVED_TAG"
            export TAG="$RESOLVED_TAG"
            export OWNER="$OWNER"

            # Create production compose file with MariaDB and Redis
            cat > docker-compose.prod.yml << 'EOF'
            # docker-compose.prod.yml
            # Production Docker Compose with internal MariaDB and Redis

            name: livrolog

            services:
              # MariaDB Database (internal, no exposed ports)
              mariadb:
                image: mariadb:10.11-jammy
                restart: always
                environment:
                  - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
                  - MYSQL_DATABASE=${DB_DATABASE}
                  - MYSQL_USER=${DB_USERNAME}
                  - MYSQL_PASSWORD=${DB_PASSWORD}
                networks:
                  - livrolog-net
                volumes:
                  - /var/www/livrolog/shared/db:/var/lib/mysql
                healthcheck:
                  # Uses root user since DB_USERNAME defaults to 'root' in this deployment
                  # For non-root users, use: mysql --silent --connect-timeout=5 -u $MYSQL_USER -p$MYSQL_PASSWORD -e 'SELECT 1'
                  test: ["CMD-SHELL", "mysql --silent --connect-timeout=3 -u root -p$$MYSQL_ROOT_PASSWORD -e 'SELECT 1' >/dev/null 2>&1"]
                  interval: 5s
                  timeout: 3s
                  retries: 20
                  start_period: 30s

              # Redis Cache (internal, no exposed ports)
              redis:
                image: redis:7-alpine
                restart: always
                networks:
                  - livrolog-net
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 3s
                  timeout: 2s
                  retries: 10
                  start_period: 5s

              # Laravel API with Nginx + PHP-FPM (serves on port 8080)
              api:
                image: ghcr.io/${OWNER:-arnonrdp}/livrolog-api:${TAG:-prod}
                restart: always
                environment:
                  # Use containerized services
                  - DB_HOST=mariadb
                  - DB_PORT=3306
                  - REDIS_HOST=redis
                  - REDIS_PORT=6379
                ports:
                  - "127.0.0.1:18081:8080"
                networks:
                  - livrolog-net
                volumes:
                  # Mount shared storage and .env from existing deployment
                  - /var/www/livrolog/shared/storage:/var/www/html/storage
                  - /var/www/livrolog/shared/.env:/var/www/html/.env
                extra_hosts:
                  - "host.docker.internal:host-gateway"
                depends_on:
                  mariadb:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                healthcheck:
                  # Simplified healthcheck using curl to test if nginx is responding
                  test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
                  interval: 10s
                  timeout: 5s
                  retries: 20
                  start_period: 60s

              # Vue/Quasar WebApp served by Nginx
              web:
                image: ghcr.io/${OWNER:-arnonrdp}/livrolog-web:${TAG:-prod}
                restart: always
                ports:
                  - "127.0.0.1:18080:80"
                networks:
                  - livrolog-net
                depends_on:
                  api:
                    condition: service_healthy
                healthcheck:
                  test: ["CMD", "sh", "-c", "curl -fsS http://localhost/healthz"]
                  interval: 15s
                  timeout: 10s
                  retries: 10
                  start_period: 30s

            networks:
              livrolog-net:
                name: livrolog-net
                driver: bridge
            EOF

            # Save current tag for rollback
            echo "$RESOLVED_TAG" > .resolved_tag_prod
            echo "$RESOLVED_TAG" > .last_tag_prod

            # Define compose command with env-file to ensure all variables are loaded
            # $COMPOSE centraliza flags comuns: --env-file garante que DB_PASSWORD e outras vars sejam lidas do .env
            # -p livrolog define project name consistente, -f especifica o compose file de produ√ß√£o
            COMPOSE="docker compose --env-file /var/www/livrolog/shared/.env -p livrolog -f docker-compose.prod.yml"
            echo "üìã Using compose command: $COMPOSE"

            # Check for optional database seeding
            echo "Checking for database seeding..."
            if [ ! -f /var/www/livrolog/shared/db/ibdata1 ] && [ -f /var/www/livrolog/shared/db-seed.sql ]; then
              echo "üå± Empty database detected with seed file available - will seed after MariaDB starts"
              SEED_REQUIRED=1
            elif [ ! -f /var/www/livrolog/shared/db/ibdata1 ]; then
              echo "üÜï Empty database detected (first run)"
              echo "‚ÑπÔ∏è Para semear: coloque o dump em /var/www/livrolog/shared/db-seed.sql e reexecute o workflow"
              SEED_REQUIRED=0
            else
              echo "‚úÖ Existing database detected"
              SEED_REQUIRED=0
            fi

            # Preflight cleanup - stop existing containers and remove orphans
            echo "üßπ Preflight cleanup - ensuring idempotent deployment..."
            echo "Stopping existing compose project if running..."
            $COMPOSE down --remove-orphans 2>/dev/null || true

            echo "Removing any orphaned containers by name..."
            docker rm -f livrolog-api livrolog-web livrolog-mariadb 2>/dev/null || true
            docker rm -f livrolog_api_1 livrolog_web_1 livrolog_mariadb_1 2>/dev/null || true

            echo "Cleaning up old networks..."
            docker network rm livrolog-net 2>/dev/null || true

            # Limpeza seletiva de espa√ßo em disco (r√°pida e eficiente)
            echo "üßπ Limpando recursos Docker n√£o utilizados..."
            # Remove apenas containers parados e volumes √≥rf√£os (r√°pido)
            timeout 10 docker system prune -f --volumes 2>/dev/null || true
            # Limpa apenas imagens antigas do LivroLog (seletivo e seguro)
            echo "üóëÔ∏è Removendo imagens antigas do LivroLog..."
            docker images | grep -E "livrolog-(api|web)" | grep -v "$RESOLVED_TAG" | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
            echo "‚úÖ Limpeza conclu√≠da"

            # Pull and start containers (idempotent)
            echo "üê≥ Pulling containers..."
            $COMPOSE pull >/dev/null 2>&1

            echo "üóÑÔ∏è Starting MariaDB and Redis..."

            # Verify database directory permissions before starting
            echo "üîç Pre-startup checks..."
            if test -d /var/www/livrolog/shared/db; then
              ls -ld /var/www/livrolog/shared/db
            else
              echo "Database directory not found (will be created)"
            fi

            # Start containers with enhanced error reporting
            echo "üê≥ Starting containers..."
            if ! $COMPOSE up -d --remove-orphans --force-recreate >/dev/null 2>&1; then
              echo "‚ùå Failed to start containers"
              echo "=== Docker Compose Status ==="
              $COMPOSE ps || true
              echo "=== Docker System Info ==="
              docker system df || true
              exit 1
            fi

            # Immediate status check
            echo "üîç Initial container status:"
            $COMPOSE ps

            # Wait for API container to start (give it 30 seconds initially)
            echo "‚è≥ Waiting for API container to start..."
            sleep 30

            # Check API container status and logs early
            echo "üîç API container status after startup:"
            API_STATUS=$($COMPOSE ps api --format "table {{.State}}" | tail -n +2)
            echo "API Status: $API_STATUS"

            if echo "$API_STATUS" | grep -q "Restarting\|Exited"; then
              echo "‚ùå API container is failing to start. Showing logs..."
              echo "=== API Container Logs (last 50 lines) ==="
              $COMPOSE logs --tail=50 api || true
              echo "=== API Container Inspect ==="
              API_CID=$($COMPOSE ps -q api)
              [ -n "$API_CID" ] && docker inspect "$API_CID" | jq '.[0].State' || true
            fi

            # Wait for MariaDB health with configurable timeout
            # Default: 600s (10 minutes), max: 1800s (30 minutes)
            DB_WAIT_TIMEOUT="${DB_HEALTH_TIMEOUT:-600}"
            [ "$DB_WAIT_TIMEOUT" -gt 1800 ] && DB_WAIT_TIMEOUT=1800

            echo "‚è≥ Waiting for MariaDB health (timeout=${DB_WAIT_TIMEOUT}s)..."
            deadline=$((SECONDS+DB_WAIT_TIMEOUT))
            while true; do
              if $COMPOSE ps mariadb | grep -q "healthy"; then
                echo "‚úÖ MariaDB is healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "‚ùå MariaDB health check timed out after ${DB_WAIT_TIMEOUT}s"
                echo "=== MariaDB Status ==="
                $COMPOSE ps mariadb
                echo "=== MariaDB Logs (last 120 lines) ==="
                $COMPOSE logs --tail=120 mariadb
                exit 1
              fi
              
              echo "Waiting for MariaDB... ($((deadline - SECONDS))s remaining)"
              sleep 10
            done

            # Wait for Redis health with configurable timeout  
            # Default: 300s (5 minutes), max: 600s (10 minutes)
            REDIS_WAIT_TIMEOUT="${REDIS_HEALTH_TIMEOUT:-300}"
            [ "$REDIS_WAIT_TIMEOUT" -gt 600 ] && REDIS_WAIT_TIMEOUT=600

            echo "‚è≥ Waiting for Redis health (timeout=${REDIS_WAIT_TIMEOUT}s)..."
            deadline=$((SECONDS+REDIS_WAIT_TIMEOUT))
            while true; do
              if $COMPOSE ps redis | grep -q "healthy"; then
                echo "‚úÖ Redis is healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "‚ùå Redis health check timed out after ${REDIS_WAIT_TIMEOUT}s"
                echo "=== Redis Status ==="
                $COMPOSE ps redis
                echo "=== Redis Logs (last 120 lines) ==="
                $COMPOSE logs --tail=120 redis
                exit 1
              fi
              
              echo "Waiting for Redis... ($((deadline - SECONDS))s remaining)"
              sleep 5
            done

            # Optional database seeding (safe and idempotent)
            if [ "$SEED_REQUIRED" -eq 1 ]; then
              echo "üå± Seeding database from /var/www/livrolog/shared/db-seed.sql..."
              if $COMPOSE exec -T mariadb mysql -u"${DB_USERNAME}" -p"${DB_PASSWORD}" "${DB_DATABASE}" < /var/www/livrolog/shared/db-seed.sql; then
                echo "‚úÖ Database seeded successfully"
              else
                echo "‚ö†Ô∏è Database seeding failed, but continuing with deployment"
              fi
            fi

            # Verify connectivity from API container to MariaDB
            echo "üîç Verifying API container connectivity..."
            API_CID=$($COMPOSE ps -q api)
            if [ -n "$API_CID" ]; then
              echo "API Container ID: $API_CID"
              echo "Testing MariaDB connectivity from API container:"
              docker exec "$API_CID" timeout 5 bash -c 'cat < /dev/null > /dev/tcp/mariadb/3306' && echo "‚úÖ MariaDB port 3306 reachable from API" || echo "‚ùå MariaDB port 3306 unreachable from API"
              
              echo "Testing Redis connectivity from API container:"
              docker exec "$API_CID" timeout 5 bash -c 'cat < /dev/null > /dev/tcp/redis/6379' && echo "‚úÖ Redis port 6379 reachable from API" || echo "‚ùå Redis port 6379 unreachable from API"
              
              echo "Testing /healthz endpoint directly from API container:"
              docker exec "$API_CID" curl -f http://localhost:8080/healthz || echo "‚ùå /healthz endpoint not responding"
              
              echo "Checking Laravel configuration:"
              docker exec "$API_CID" php artisan config:show database.connections.mysql.host || echo "‚ùå Cannot show DB config"
              docker exec "$API_CID" php artisan config:show database.redis.default.host || echo "‚ùå Cannot show Redis config"
              
              echo "Testing basic Laravel functionality:"
              docker exec "$API_CID" php artisan about --only=environment || echo "‚ùå Laravel about command failed"
            else
              echo "‚ùå No API container found for connectivity testing"
            fi

            # Wait for health checks with timeout
            echo "‚è≥ Waiting for services to be healthy (max 180s)..."
            deadline=$((SECONDS+180))
            while true; do
              web_ok=0; api_ok=0
              # Check web health
              curl -fsS "http://127.0.0.1:18080/healthz" >/dev/null 2>&1 && web_ok=1
              # Check api health  
              curl -fsS "http://127.0.0.1:18081/healthz" >/dev/null 2>&1 && api_ok=1
              
              if [ "$web_ok" -eq 1 ] && [ "$api_ok" -eq 1 ]; then 
                echo "‚úÖ All services are healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "‚ùå Health checks timed out, performing rollback..."
                
                echo "=== Container Status ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
                echo "=== MariaDB Logs (last 80 lines) ==="
                $COMPOSE logs --tail=80 mariadb || true
                echo "=== API Logs (last 80 lines) ==="
                $COMPOSE logs --tail=80 api || true
                echo "=== Web Logs (last 80 lines) ==="
                $COMPOSE logs --tail=80 web || true
                
                echo "=== API->MariaDB connectivity test ==="
                API_CID=$($COMPOSE ps -q api)
                [ -n "$API_CID" ] && docker exec "$API_CID" timeout 5 bash -c 'cat </dev/null >/dev/tcp/mariadb/3306' && echo "‚úÖ API can reach MariaDB" || echo "‚ùå API cannot reach MariaDB"
                
                # Idempotent rollback (preserve DB volume)
                echo "üîÑ Performing idempotent rollback..."
                $COMPOSE down --remove-orphans 2>/dev/null || true
                LAST_TAG=$(cat .last_tag_prod 2>/dev/null || echo "prod")
                export TAG="$LAST_TAG"
                echo "Rolling back to tag: $TAG"
                $COMPOSE pull 2>/dev/null || true
                $COMPOSE up -d --remove-orphans --force-recreate 2>/dev/null || true
                exit 1
              fi
              sleep 5
            done

            # Run migrations and clear caches using dynamic container names
            echo "üîÑ Rodando migrations..."
            API_CONTAINER=$($COMPOSE ps -q api | head -n 1)
            if [ -z "$API_CONTAINER" ]; then
              echo "‚ùå No API container found!"
              exit 1
            fi
            docker exec "$API_CONTAINER" php artisan migrate --force

            echo "üßπ Clearing caches..."
            docker exec "$API_CONTAINER" php artisan config:clear || true
            docker exec "$API_CONTAINER" php artisan cache:clear || true
            docker exec "$API_CONTAINER" php artisan config:cache || true
            docker exec "$API_CONTAINER" php artisan route:cache || true

            # Smoke tests
            echo "üß™ Running smoke tests..."
            echo "Testing web frontend:"
            curl -I http://127.0.0.1:18080/ || exit 1
            echo "Testing API health:"
            curl -I http://127.0.0.1:18081/healthz || exit 1

            # Test database connectivity from API
            echo "Testing database connectivity from API:"
            DB_TEST_OUTPUT=$(docker exec "$API_CONTAINER" php artisan tinker --execute="try { DB::connection()->getPdo(); echo 'DB_OK'; } catch (Exception \$e) { echo 'DB_FAIL'; exit(1); }" 2>&1)
            if echo "$DB_TEST_OUTPUT" | grep -q "DB_OK"; then
              echo "‚úÖ Database connection ok"
            else
              echo "‚ùå Database connection failed"
              echo "Debug output: $DB_TEST_OUTPUT"
              exit 1
            fi

            # Test Redis connectivity
            echo "Testing Redis connectivity:"
            REDIS_TEST_OUTPUT=$($COMPOSE exec -T redis redis-cli ping 2>&1)
            if echo "$REDIS_TEST_OUTPUT" | grep -q "PONG"; then
              echo "‚úÖ Redis connection ok"
            else
              echo "‚ùå Redis connection failed"
              echo "Debug output: $REDIS_TEST_OUTPUT"
              exit 1
            fi

            echo "‚úÖ All smoke tests passed"
            echo "Container status:"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'

            echo "‚úÖ Production Docker deployment completed successfully!"
            echo "üåê Web: http://127.0.0.1:18080"
            echo "üîå API: http://127.0.0.1:18081"
