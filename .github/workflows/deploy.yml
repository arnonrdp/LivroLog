name: Deploy

on:
  push:
    branches:
      - main
      - dev
  workflow_dispatch:

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'

permissions:
  contents: read
  packages: write
  attestations: write
  id-token: write

jobs:
  required-checks:
    uses: ./.github/workflows/required-checks.yml

  build:
    needs: required-checks
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
    secrets: inherit

  # Legacy deploy job (disabled - Docker containers handle deployment now)
  # deploy:
  #   name: deploy
  #   runs-on: ubuntu-latest
  #   needs: [required-checks, build]
  #   if: false  # Disabled in favor of Docker containers

  # post-deploy:
  #   name: post-deploy
  #   needs: [deploy]
  #   uses: ./.github/workflows/post-deploy.yml
  #   with:
  #     environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
  #   secrets: inherit

  # Legacy rollback (disabled - Docker containers handle rollback now)

  # Docker container deployments are the primary deployment method
  docker-canary-dev:
    name: docker-canary-dev
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && github.ref == 'refs/heads/dev'

    env:
      ENVIRONMENT: Development
      DEPLOY_PATH: /var/www/livrolog-dev
      GHCR_PAT: ${{ secrets.GHCR_PAT }}

    steps:
      - name: Deploy canary containers (livrolog-dev)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_PAT,GITHUB_SHA,GITHUB_REF_NAME
          script: |
            set -euo pipefail
            DOCKER_DIR="/var/www/livrolog-dev/docker"
            OWNER="arnonrdp"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            sudo mkdir -p "$DOCKER_DIR"
            sudo chown -R bitnami:bitnami /var/www/livrolog-dev
            cd "$DOCKER_DIR"

            # Login condicional no GHCR (se GHCR_PAT estiver definido e não vazio)
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u arnonrdp --password-stdin
            else
              echo "Aviso: GHCR_PAT vazio. Se os pacotes forem privados, o pull falhará."
            fi

            # Encontrar porta livre entre 8082-8090
            WEB_PORT=""
            for port in {8082..8090}; do
              if ! ss -ltn | grep -q ":${port} "; then
                WEB_PORT=$port
                break
              fi
            done

            if [ -z "$WEB_PORT" ]; then
              echo "❌ Nenhuma porta disponível entre 8082-8090. Verifique processos em execução." >&2
              exit 1
            fi

            echo "🔍 Usando porta ${WEB_PORT} para web"

            # Opcional: limpar containers antigos do LivroLog
            docker rm -f livrolog-web-dev livrolog-web 2>/dev/null || true

            # Gera compose dev
            cat > docker-compose.dev.yml << EOF
            name: livrolog_dev
            services:
              web:
                image: REPLACE_WEB_IMAGE
                container_name: livrolog-web-dev
                restart: always
                ports:
                  - "${WEB_PORT}:80"
                healthcheck:
                  test: ["CMD", "curl", "-fsS", "http://localhost/healthz"]
                  interval: 15s
                  timeout: 3s
                  retries: 10
                depends_on:
                  - api
              api:
                image: REPLACE_API_IMAGE
                container_name: livrolog-api-dev
                restart: always
                env_file:
                  - /var/www/livrolog-dev/shared/.env.dev
                environment:
                  - DB_HOST=127.0.0.1
                  - DB_PORT=3306
                  - REDIS_HOST=127.0.0.1
                  - REDIS_PORT=6379
                network_mode: host
                volumes:
                  - /var/www/livrolog-dev/shared/storage:/var/www/html/storage
                healthcheck:
                  test: ["CMD", "php", "artisan", "about"]
                  interval: 10s
                  timeout: 5s
                  retries: 30
                  start_period: 60s
            EOF

            # Resolve tag existente: dev-<sha> -> <sha> -> dev
            BRANCH="${GITHUB_REF_NAME:-dev}"
            SHA="${GITHUB_SHA}"
            CANDIDATES=("${BRANCH}-${SHA}" "${SHA}" "dev")

            RESOLVED_TAG=""
            for tag in "${CANDIDATES[@]}"; do
              if docker manifest inspect "${IMAGE_WEB}:${tag}" >/dev/null 2>&1 && docker manifest inspect "${IMAGE_API}:${tag}" >/dev/null 2>&1; then
                RESOLVED_TAG="${tag}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "❌ Nenhuma tag encontrada (testadas: ${CANDIDATES[*]}). Verifique as tags publicadas no GHCR." >&2
              exit 1
            fi

            echo "$RESOLVED_TAG" > .resolved_tag_dev
            echo "$RESOLVED_TAG" > .last_tag_dev
            export TAG="$RESOLVED_TAG"

            # Substitui as imagens no compose
            sed -i "s|REPLACE_WEB_IMAGE|${IMAGE_WEB}:${TAG}|g" docker-compose.dev.yml
            sed -i "s|REPLACE_API_IMAGE|${IMAGE_API}:${TAG}|g" docker-compose.dev.yml

            # Verificar .env e storage antes do up (fail-fast com mensagem clara)
            test -f /var/www/livrolog-dev/shared/.env.dev || { echo "❌ /var/www/livrolog-dev/shared/.env.dev não existe"; exit 1; }
            test -d /var/www/livrolog-dev/shared/storage || { echo "❌ /var/www/livrolog-dev/shared/storage não existe"; exit 1; }

            # Pull e start
            docker compose -p livrolog_dev -f docker-compose.dev.yml pull
            docker compose -p livrolog_dev -f docker-compose.dev.yml up -d --remove-orphans

            # Espera healthchecks
            echo "Waiting for services to be healthy (max 120s)…"
            deadline=$((SECONDS+120))
            while true; do
              web_ok=0; api_ok=0
              curl -fsS "http://localhost:${WEB_PORT}/healthz" >/dev/null 2>&1 && web_ok=1
              docker exec livrolog-api-dev php artisan about >/dev/null 2>&1 && api_ok=1
              if [ "$web_ok" -eq 1 ] && [ "$api_ok" -eq 1 ]; then break; fi
              if [ $SECONDS -ge $deadline ]; then
                echo "❌ Health checks failed, rolling back…"
                echo "=== Diagnóstico de containers ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
                echo "=== Health status da API ==="
                docker inspect --format='{{json .State.Health}}' livrolog-api-dev | jq . || true
                echo "=== Logs da API (últimas 80 linhas) ==="
                docker logs --tail=80 livrolog-api-dev || true
                echo "=== Logs da Web (últimas 80 linhas) ==="
                docker logs --tail=80 livrolog-web-dev || true
                echo "=== Iniciando rollback ==="
                LAST_TAG=$(cat .last_tag_dev 2>/dev/null || echo "dev")
                export TAG="$LAST_TAG"
                sed -i "s|ghcr.io/.*/livrolog-web:.*|${IMAGE_WEB}:${TAG}|g" docker-compose.dev.yml
                sed -i "s|ghcr.io/.*/livrolog-api:.*|${IMAGE_API}:${TAG}|g" docker-compose.dev.yml
                docker compose -p livrolog_dev -f docker-compose.dev.yml pull
                docker compose -p livrolog_dev -f docker-compose.dev.yml up -d --remove-orphans
                exit 1
              fi
              sleep 5
            done

            # Migrations e caches
            docker exec livrolog-api-dev php artisan migrate --force
            docker exec livrolog-api-dev php artisan config:clear || true
            docker exec livrolog-api-dev php artisan cache:clear || true

            echo "✅ Canary OK em http://$(hostname -I | awk '{print $1}'):${WEB_PORT}"

  docker-canary-prod:
    name: docker-canary-prod
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && github.ref == 'refs/heads/main'

    env:
      ENVIRONMENT: Production
      DEPLOY_PATH: /var/www/livrolog
      GHCR_PAT: ${{ secrets.GHCR_PAT }}
      APP_KEY: ${{ secrets.APP_KEY }}

    steps:
      - name: Checkout code for compose file
        uses: actions/checkout@v4

      - name: Deploy production containers
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: GHCR_PAT,GITHUB_SHA,GITHUB_REF_NAME,APP_KEY
          script: |
            set -eu
            DOCKER_DIR="/var/www/livrolog/docker"
            OWNER="arnonrdp"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"

            # Create docker directory and set permissions
            sudo mkdir -p "$DOCKER_DIR"
            sudo chown -R bitnami:bitnami /var/www/livrolog
            cd "$DOCKER_DIR"

            # Auto-provision/repair .env (POSIX + idempotent)
            echo "🔧 Auto-provisioning .env (APP_KEY)..."
            sudo mkdir -p /var/www/livrolog/shared
            sudo touch /var/www/livrolog/shared/.env
            sudo chown -R "$USER:$USER" /var/www/livrolog
            
            # Função POSIX para gerar APP_KEY compatível com Laravel (sem depender de imagens externas)
            gen_app_key() {
              if command -v head >/dev/null 2>&1 && command -v base64 >/dev/null 2>&1; then
                head -c 32 /dev/urandom | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              elif command -v openssl >/dev/null 2>&1; then
                openssl rand -base64 32 | tr -d '\n' | awk '{print "base64:" $0}'
              else
                dd if=/dev/urandom bs=32 count=1 2>/dev/null | base64 | tr -d '\n' | awk '{print "base64:" $0}'
              fi
            }
            
            # 1) Tenta usar a secret APP_KEY; se ausente/inválida, gera automaticamente
            APP_KEY_CAND="${APP_KEY:-}"
            if ! printf '%s' "$APP_KEY_CAND" | grep -Eq '^base64:[A-Za-z0-9+/=]{44}$'; then
              echo "⚠️ APP_KEY secret ausente/inválido; gerando automaticamente..."
              APP_KEY_CAND="$(gen_app_key || true)"
            fi
            
            # 2) Valida e grava no .env (operação atômica)
            if printf '%s' "$APP_KEY_CAND" | grep -Eq '^base64:[A-Za-z0-9+/=]{44}$'; then
              tmpfile="$(mktemp)"
              # Remove qualquer APP_KEY existente e escreve a nova (seguro p/ caracteres especiais)
              grep -v '^APP_KEY=' /var/www/livrolog/shared/.env > "$tmpfile" || true
              printf 'APP_KEY=%s\n' "$APP_KEY_CAND" >> "$tmpfile"
              mv "$tmpfile" /var/www/livrolog/shared/.env
              echo "✅ APP_KEY provisionada/atualizada em /var/www/livrolog/shared/.env"
            else
              echo "❌ Falha ao provisionar APP_KEY automaticamente (não foi possível obter uma chave válida)"
              exit 1
            fi

            # Pre-checks: verify environment and infrastructure
            echo "🔍 Performing pre-deployment checks..."
            
            # Check 1: .env file exists
            test -f /var/www/livrolog/shared/.env || { echo "❌ /var/www/livrolog/shared/.env não existe"; exit 1; }
            test -d /var/www/livrolog/shared/storage || { echo "❌ /var/www/livrolog/shared/storage não existe"; exit 1; }
            
            # Validação correta da APP_KEY no .env (44+ chars após base64:)
            echo "Validating APP_KEY in .env..."
            if ! grep -Eq '^APP_KEY=base64:[A-Za-z0-9+/=]{44}$' /var/www/livrolog/shared/.env; then
              echo "❌ APP_KEY inválido/ausente em /var/www/livrolog/shared/.env"
              echo ""
              echo "🔧 Para corrigir:"
              echo "   1. Gere uma chave válida:"
              echo "      docker run --rm -v /var/www/livrolog/shared:/app -w /var/www/html ghcr.io/arnonrdp/livrolog-api:prod bash -lc 'php artisan key:generate --show'"
              echo ""
              echo "   2. Adicione a chave ao arquivo .env:"
              echo "      sudo nano /var/www/livrolog/shared/.env"
              echo "      # Insira a linha: APP_KEY=base64:chave_gerada_acima"
              echo ""
              exit 1
            fi
            echo "✅ APP_KEY válida encontrada"
            
            # Check 3: MySQL/MariaDB bind-address detection
            echo "Checking MySQL/MariaDB bind configuration..."
            if ss -ltn | awk '{print $4}' | grep -qE '(^|:)127\.0\.0\.1:3306'; then
              echo "⚠️ MySQL ouvindo apenas em 127.0.0.1:3306. Ajuste bind-address=0.0.0.0 para containers alcançarem."
              echo ""
              echo "🔧 Para corrigir no servidor:"
              echo ""
              echo "   Bitnami MariaDB:"
              echo "     sudo sed -i 's/^\s*bind-address\s*=.*/bind-address=0.0.0.0/' /opt/bitnami/mariadb/conf/my.cnf"
              echo "     sudo sed -i 's/^\s*skip-networking/# skip-networking/' /opt/bitnami/mariadb/conf/my.cnf"
              echo "     sudo /opt/bitnami/ctlscript.sh restart mariadb"
              echo ""
              echo "   Ubuntu/Debian padrão:"
              echo "     sudo sed -i 's/^\s*bind-address\s*=.*/bind-address = 0.0.0.0/' /etc/mysql/mysql.conf.d/mysqld.cnf"
              echo "     sudo sed -i 's/^\s*skip-networking/# skip-networking/' /etc/mysql/mysql.conf.d/mysqld.cnf"
              echo "     sudo systemctl restart mysql"
              echo ""
              echo "   Firewall (se UFW estiver disponível):"
              echo "     sudo ufw allow from 172.17.0.0/16 to any port 3306 proto tcp"
              echo ""
              echo "❌ Corrigir configuração do MySQL e executar novamente o deploy"
              exit 1
            fi
            echo "✅ MySQL ouvindo em 0.0.0.0:3306"

            # Login to GHCR if PAT is available
            if [ -n "${GHCR_PAT:-}" ]; then
              echo "$GHCR_PAT" | docker login ghcr.io -u arnonrdp --password-stdin
            else
              echo "⚠️ GHCR_PAT not set. Using public access."
            fi

            # Resolve tag: prefer 'prod', fallback to SHA
            BRANCH="${GITHUB_REF_NAME:-main}"
            SHA="${GITHUB_SHA}"
            CANDIDATES=("prod" "${SHA}" "main")

            RESOLVED_TAG=""
            for tag in "${CANDIDATES[@]}"; do
              if docker manifest inspect "${IMAGE_WEB}:${tag}" >/dev/null 2>&1 && docker manifest inspect "${IMAGE_API}:${tag}" >/dev/null 2>&1; then
                RESOLVED_TAG="${tag}"
                break
              fi
            done

            if [ -z "$RESOLVED_TAG" ]; then
              echo "❌ Nenhuma tag encontrada (testadas: ${CANDIDATES[*]})"
              exit 1
            fi

            echo "🏷️ Using resolved tag: $RESOLVED_TAG"
            export TAG="$RESOLVED_TAG"
            export OWNER="$OWNER"

            # Create production compose file
            cat > docker-compose.prod.yml << 'EOF'
            # docker-compose.prod.yml
            # Production Docker Compose with internal network and loopback ports
            
            name: livrolog
            
            services:
              # Laravel API with Nginx + PHP-FPM (serves on port 8080)
              api:
                image: ghcr.io/${OWNER:-arnonrdp}/livrolog-api:${TAG:-prod}
                restart: always
                environment:
                  # Override DB/Redis to use external services via host gateway
                  - DB_HOST=host.docker.internal
                  - DB_PORT=3306
                  - REDIS_HOST=host.docker.internal
                  - REDIS_PORT=6379
                ports:
                  - "127.0.0.1:18081:8080"
                networks:
                  - livrolog-net
                volumes:
                  # Mount shared storage and .env from existing deployment
                  - /var/www/livrolog/shared/storage:/var/www/html/storage
                  - /var/www/livrolog/shared/.env:/var/www/html/.env:ro
                extra_hosts:
                  - "host.docker.internal:host-gateway"
                healthcheck:
                  test: ["CMD", "curl", "-fsS", "http://localhost:8080/health"]
                  interval: 15s
                  timeout: 5s
                  retries: 10
                  start_period: 30s
            
              # Vue/Quasar WebApp served by Nginx
              web:
                image: ghcr.io/${OWNER:-arnonrdp}/livrolog-web:${TAG:-prod}
                restart: always
                ports:
                  - "127.0.0.1:18080:80"
                networks:
                  - livrolog-net
                depends_on:
                  - api
                healthcheck:
                  test: ["CMD", "sh", "-c", "curl -fsS http://localhost/healthz"]
                  interval: 15s
                  timeout: 10s
                  retries: 10
                  start_period: 30s
            
            networks:
              livrolog-net:
                name: livrolog-net
                driver: bridge
            EOF

            # Save current tag for rollback
            echo "$RESOLVED_TAG" > .resolved_tag_prod
            echo "$RESOLVED_TAG" > .last_tag_prod

            # Preflight cleanup - stop existing containers and remove orphans
            echo "🧹 Preflight cleanup - ensuring idempotent deployment..."
            echo "Stopping existing compose project if running..."
            docker compose -p livrolog -f docker-compose.prod.yml down --remove-orphans || true
            
            echo "Removing any orphaned containers by name..."
            docker rm -f livrolog-api livrolog-web || true
            docker rm -f livrolog_api_1 livrolog_web_1 || true
            
            echo "Cleaning up old networks..."
            docker network rm livrolog-net || true

            # Pull and start containers (idempotent)
            echo "🐳 Pulling and starting containers with force-recreate..."
            docker compose -p livrolog -f docker-compose.prod.yml pull
            docker compose -p livrolog -f docker-compose.prod.yml up -d --remove-orphans --force-recreate

            # Verify connectivity from API container to host services
            echo "🔍 Verifying API container connectivity..."
            API_CID=$(docker compose -p livrolog ps -q api)
            if [ -n "$API_CID" ]; then
              echo "API Container ID: $API_CID"
              echo "Testing host.docker.internal resolution:"
              docker exec "$API_CID" getent hosts host.docker.internal || true
              echo "Testing database connectivity:"
              docker exec "$API_CID" timeout 5 bash -c 'cat < /dev/null > /dev/tcp/host.docker.internal/3306' && echo "✅ Database port 3306 reachable" || echo "❌ Database port 3306 unreachable"
            fi

            # Wait for health checks with timeout
            echo "⏳ Waiting for services to be healthy (max 180s)..."
            deadline=$((SECONDS+180))
            while true; do
              web_ok=0; api_ok=0
              # Check web health
              curl -fsS "http://127.0.0.1:18080/healthz" >/dev/null 2>&1 && web_ok=1
              # Check api health  
              curl -fsS "http://127.0.0.1:18081/health" >/dev/null 2>&1 && api_ok=1
              
              if [ "$web_ok" -eq 1 ] && [ "$api_ok" -eq 1 ]; then 
                echo "✅ All services are healthy"
                break
              fi
              
              if [ $SECONDS -ge $deadline ]; then
                echo "❌ Health checks timed out, performing rollback..."
                
                echo "=== Host DB socket/listeners ==="
                sudo ss -ltnp | (grep :3306 || true) || true
                echo "=== UFW status ==="
                if command -v ufw >/dev/null 2>&1; then
                  sudo ufw status || true
                else
                  echo "ℹ️ ufw not installed on host"
                fi

                echo "=== API->DB TCP test ==="
                API_CID=$(docker compose -p livrolog ps -q api)
                [ -n "$API_CID" ] && docker exec "$API_CID" bash -lc 'nc -vz host.docker.internal 3306 || (timeout 5 bash -lc "cat </dev/null >/dev/tcp/host.docker.internal/3306")' || true
                
                echo "=== Container Status ==="
                docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
                echo "=== Web Logs (last 120 lines) ==="
                docker logs --tail=120 $(docker compose -p livrolog ps -q web) || true
                echo "=== API Logs (last 120 lines) ==="
                docker logs --tail=120 $(docker compose -p livrolog ps -q api) || true
                
                # Idempotent rollback
                echo "🔄 Performing idempotent rollback..."
                docker compose -p livrolog -f docker-compose.prod.yml down --remove-orphans || true
                LAST_TAG=$(cat .last_tag_prod 2>/dev/null || echo "prod")
                export TAG="$LAST_TAG"
                echo "Rolling back to tag: $TAG"
                docker compose -p livrolog -f docker-compose.prod.yml pull
                docker compose -p livrolog -f docker-compose.prod.yml up -d --remove-orphans --force-recreate
                exit 1
              fi
              sleep 5
            done

            # Run migrations and clear caches using dynamic container names
            echo "🔄 Running migrations..."
            API_CONTAINER=$(docker compose -p livrolog ps -q api | head -n 1)
            if [ -z "$API_CONTAINER" ]; then
              echo "❌ No API container found!"
              exit 1
            fi
            docker exec "$API_CONTAINER" php artisan migrate --force

            echo "🧹 Clearing caches..."
            docker exec "$API_CONTAINER" php artisan config:clear || true
            docker exec "$API_CONTAINER" php artisan cache:clear || true
            docker exec "$API_CONTAINER" php artisan config:cache || true
            docker exec "$API_CONTAINER" php artisan route:cache || true

            # Smoke tests
            echo "🧪 Running smoke tests..."
            echo "Testing web frontend:"
            curl -I http://127.0.0.1:18080/ || exit 1
            echo "Testing API health:"
            curl -I http://127.0.0.1:18081/health || exit 1
            echo "Container status:"
            docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'

            echo "✅ Production Docker deployment completed successfully!"
            echo "🌐 Web: http://127.0.0.1:18080"
            echo "🔌 API: http://127.0.0.1:18081"
