name: Deploy

on:
  push:
    branches:
      - main
      - dev
    paths:
      - '.github/workflows/deploy.yml'
      - 'api/**'
      - 'webapp/**'
      - 'docker/**'
      - '**/Dockerfile'
  workflow_dispatch:
    inputs:
      branch:
        description: 'Target branch to deploy'
        required: false
        default: 'dev'
        type: choice
        options:
          - 'main'
          - 'dev'

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'
  TARGET_BRANCH: ${{ github.event.inputs.branch || github.ref_name }}

permissions:
  contents: read
  packages: write
  attestations: write
  id-token: write

jobs:
  required-checks:
    uses: ./.github/workflows/required-checks.yml

  build:
    needs: required-checks
    uses: ./.github/workflows/build.yml
    with:
      environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
    secrets: inherit

  # Legacy deploy job (disabled - Docker containers handle deployment now)
  # deploy:
  #   name: deploy
  #   runs-on: ubuntu-latest
  #   needs: [required-checks, build]
  #   if: false  # Disabled in favor of Docker containers

  # post-deploy:
  #   name: post-deploy
  #   needs: [deploy]
  #   uses: ./.github/workflows/post-deploy.yml
  #   with:
  #     environment: ${{ github.ref == 'refs/heads/main' && 'Production' || 'Development' }}
  #   secrets: inherit

  # Legacy rollback (disabled - Docker containers handle rollback now)

  # Docker container deployments are the primary deployment method
  docker-canary-dev:
    name: docker-canary-dev
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/dev' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'dev'))

    env:
      ENVIRONMENT: Development
      TARGET_BRANCH: dev
      DEPLOY_PATH: /var/www/livrolog-dev
      GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
      GITHUB_SHA: ${{ github.sha }}
      GITHUB_REF_NAME: ${{ github.ref_name }}

    steps:
      - name: Checkout code for compose file
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate required secrets
        run: |
          echo "üîç Validating required secrets and environment variables..."
          
          # Check required secrets
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå SERVER_HOST secret is not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            echo "‚ùå SERVER_USER secret is not configured" 
            exit 1
          fi
          
          if [ -z "${{ secrets.SERVER_SSH_KEY }}" ]; then
            echo "‚ùå SERVER_SSH_KEY secret is not configured"
            exit 1
          fi
          
          # GHCR_PAT is optional for public images, but warn if missing
          if [ -z "${{ secrets.GHCR_PAT }}" ]; then
            echo "‚ö†Ô∏è GHCR_PAT secret not found - will attempt to pull public images"
          fi
          
          echo "‚úÖ Secret validation completed"

      - name: Setup SSH key and test connection
        run: |
          echo "üîê Setting up SSH connection..."
          
          # Create SSH directory and set permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Create SSH private key file
          echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/livrolog_key
          chmod 600 ~/.ssh/livrolog_key
          
          # Disable host key checking for this deployment (AWS instances change IPs)
          echo "Host ${{ secrets.SERVER_HOST }}" >> ~/.ssh/config
          echo "  HostName ${{ secrets.SERVER_HOST }}" >> ~/.ssh/config
          echo "  User ${{ secrets.SERVER_USER }}" >> ~/.ssh/config
          echo "  IdentityFile ~/.ssh/livrolog_key" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          echo "  LogLevel QUIET" >> ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # Test SSH connection
          echo "üîç Testing SSH connection to ${{ secrets.SERVER_HOST }}..."
          if ssh ${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connection test passed"
          else
            echo "‚ùå SSH connection test failed"
            echo "Debug information:"
            echo "  Host: ${{ secrets.SERVER_HOST }}"
            echo "  User: ${{ secrets.SERVER_USER }}"
            echo "  Key length: ${#{{ secrets.SERVER_SSH_KEY }}}"
            exit 1
          fi

      - name: Copy compose file to server
        run: |
          echo "üìÅ Copying docker-compose.dev.yml to server..."
          
          # Create target directory on server
          ssh ${{ secrets.SERVER_HOST }} "sudo mkdir -p ${DEPLOY_PATH}/docker && sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} ${DEPLOY_PATH}"
          
          # Copy compose file
          scp -o StrictHostKeyChecking=no docker-compose.dev.yml ${{ secrets.SERVER_HOST }}:${DEPLOY_PATH}/docker/
          
          echo "‚úÖ Docker compose file copied successfully"

      - name: Deploy development containers  
        run: |
          ssh ${{ secrets.SERVER_HOST }} << 'DEPLOY_SCRIPT'
            set -euo pipefail
            # Configuration
            DOCKER_DIR="${{ env.DEPLOY_PATH }}/docker"
            SHARED_DIR="${{ env.DEPLOY_PATH }}/shared"
            OWNER="${{ env.GITHUB_REPOSITORY_OWNER }}"
            TAG="dev"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"
            
            echo "=================================================="
            echo "üöÄ LivroLog Development Deployment"
            echo "Branch: ${{ env.TARGET_BRANCH }}"
            echo "SHA: ${{ env.GITHUB_SHA }}"
            echo "Images: ${IMAGE_API}:${TAG}, ${IMAGE_WEB}:${TAG}"
            echo "Deploy Path: ${{ env.DEPLOY_PATH }}"
            echo "=================================================="
            
            # Create required directories with proper permissions
            echo "üìÅ Setting up directories and permissions..."
            sudo mkdir -p "${SHARED_DIR}"/{storage,db}
            sudo mkdir -p "${DOCKER_DIR}"
            
            # Set MySQL data directory permissions (UID 999)
            sudo chown -R 999:999 "${SHARED_DIR}/db"
            
            # Set Laravel storage permissions (www-data)
            sudo chown -R www-data:www-data "${SHARED_DIR}/storage" 2>/dev/null || sudo chown -R 82:82 "${SHARED_DIR}/storage"
            
            # Set deployment directory permissions
            sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} "${{ env.DEPLOY_PATH }}"
            
            # Create development environment file (fixed format)
            echo "üìù Creating development .env file..."
            cat > "${SHARED_DIR}/.env.dev" << 'ENV_EOF'
            APP_NAME=LivroLog
            APP_ENV=development
            APP_KEY=base64:UGxhY2Vob2xkZXJLZXlGb3JEZXZlbG9wbWVudA==
            APP_DEBUG=true
            APP_TIMEZONE=UTC
            
            DB_CONNECTION=mysql
            DB_HOST=mysql
            DB_PORT=3306
            DB_DATABASE=livrolog_dev
            DB_USERNAME=livrolog
            DB_PASSWORD=supersecret
            
            REDIS_CLIENT=predis
            REDIS_HOST=redis
            REDIS_PASSWORD=null
            REDIS_PORT=6379
            
            QUEUE_CONNECTION=redis
            SESSION_DRIVER=redis
            SESSION_LIFETIME=120
            CACHE_DRIVER=redis
            MAIL_MAILER=log
            LOG_CHANNEL=stack
            LOG_LEVEL=debug
            ENV_EOF
            
            echo "‚úÖ Environment file created"
            
            # Check if containers are already running and restart API if needed
            if docker ps | grep -q livrolog-api-dev; then
              echo "üîÑ Restarting existing API container to apply new environment..."
              docker restart livrolog-api-dev
              sleep 15
            fi
            
            # Navigate to docker directory
            cd "${DOCKER_DIR}"
            
            # Login to GitHub Container Registry if PAT available
            if [ -n "${{ secrets.GHCR_PAT }}" ]; then
              echo "üîê Authenticating with GitHub Container Registry..."
              echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u "${{ env.GITHUB_REPOSITORY_OWNER }}" --password-stdin
            else
              echo "‚ö†Ô∏è No GHCR_PAT provided - attempting to pull public images"
            fi
            
            # Pull latest images with error handling
            echo "üì¶ Pulling latest Docker images..."
            if ! docker pull "${IMAGE_API}:${TAG}"; then
              echo "‚ö†Ô∏è Failed to pull API image ${IMAGE_API}:${TAG}"
              echo "Available API tags:"
              docker images | grep livrolog-api || echo "No local API images found"
            fi
            
            if ! docker pull "${IMAGE_WEB}:${TAG}"; then
              echo "‚ö†Ô∏è Failed to pull Web image ${IMAGE_WEB}:${TAG}"
              echo "Available Web tags:"
              docker images | grep livrolog-web || echo "No local Web images found"
            fi
            
            # Stop existing containers gracefully
            echo "üõë Stopping existing development containers..."
            if docker compose -f docker-compose.dev.yml ps --services --filter "status=running" | grep -q .; then
              docker compose -f docker-compose.dev.yml down --timeout 30
              echo "‚úÖ Existing containers stopped"
            else
              echo "‚ÑπÔ∏è No running containers to stop"
            fi
            
            # Clean up orphaned containers and networks
            echo "üßπ Cleaning up orphaned resources..."
            docker container prune -f --filter "label=com.docker.compose.project=livrolog_dev" || true
            docker network prune -f || true
            
            # Export environment variables for docker-compose
            export GITHUB_REPOSITORY_OWNER="${OWNER}"
            export TAG="${TAG}"
            export DB_DATABASE="livrolog_dev"
            export DB_USERNAME="livrolog"
            export DB_PASSWORD="supersecret"
            
            # Start containers with health checks
            echo "üöÄ Starting development containers..."
            if ! docker compose -f docker-compose.dev.yml up -d --remove-orphans; then
              echo "‚ùå Failed to start containers"
              echo "=== Docker Compose Logs ==="
              docker compose -f docker-compose.dev.yml logs --tail=50
              exit 1
            fi
            
            echo "‚úÖ Containers started successfully"
            
            # Wait for containers to initialize
            echo "‚è≥ Waiting for containers to initialize (60 seconds)..."
            sleep 60
            
            # Health checks with detailed status
            echo "üîç Performing health checks..."
            
            # Check container status
            echo "üìä Container Status:"
            docker compose -f docker-compose.dev.yml ps
            
            # Check MySQL connectivity
            echo "üîç Testing MySQL connectivity..."
            for i in {1..12}; do
              if docker exec livrolog-mysql-dev mysqladmin ping -u root -psupersecret --silent 2>/dev/null; then
                echo "‚úÖ MySQL is responding (attempt $i)"
                break
              elif [ $i -eq 12 ]; then
                echo "‚ùå MySQL health check failed after 12 attempts"
                docker logs livrolog-mysql-dev --tail=20
                exit 1
              else
                echo "‚è≥ MySQL not ready yet (attempt $i/12), waiting 10 seconds..."
                sleep 10
              fi
            done
            
            # Check Redis connectivity  
            echo "üîç Testing Redis connectivity..."
            if docker exec livrolog-redis-dev redis-cli ping >/dev/null 2>&1; then
              echo "‚úÖ Redis is responding"
            else
              echo "‚ùå Redis health check failed"
              docker logs livrolog-redis-dev --tail=20
              exit 1
            fi
            
            # Check API health endpoint
            echo "üîç Testing API health endpoint..."
            for i in {1..24}; do  
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8081/healthz 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ API health endpoint responding (HTTP $HTTP_CODE)"
                break
              elif [ $i -eq 24 ]; then
                echo "‚ùå API health endpoint failed after 24 attempts (HTTP $HTTP_CODE)"
                echo "=== API Container Logs ==="
                docker logs livrolog-api-dev --tail=30
                exit 1
              else
                echo "‚è≥ API not ready yet (HTTP $HTTP_CODE, attempt $i/24), waiting 10 seconds..."
                sleep 10
              fi
            done
            
            # Check Web frontend
            echo "üîç Testing Web frontend..."  
            for i in {1..12}; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8080/ 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ Web frontend responding (HTTP $HTTP_CODE)"
                break
              elif [ $i -eq 12 ]; then
                echo "‚ùå Web frontend failed after 12 attempts (HTTP $HTTP_CODE)"
                echo "=== Web Container Logs ==="
                docker logs livrolog-web-dev --tail=30
                exit 1
              else
                echo "‚è≥ Web not ready yet (HTTP $HTTP_CODE, attempt $i/12), waiting 5 seconds..."
                sleep 5
              fi
            done
            
            echo "=================================================="
            echo "üéâ Development deployment completed successfully!"
            echo "üìç Services:"
            echo "  ‚Ä¢ Web Frontend: http://127.0.0.1:8080 (dev.livrolog.com)"
            echo "  ‚Ä¢ API Backend: http://127.0.0.1:8081 (api.dev.livrolog.com)"
            echo "  ‚Ä¢ MySQL: 127.0.0.1:3307"
            echo "  ‚Ä¢ Redis: 127.0.0.1:6380"
            echo "=================================================="
            
          DEPLOY_SCRIPT

      - name: Configure Apache proxy for development containers
        run: |
          echo "üîß Configuring Apache proxy for development containers..."
          
          ssh ${{ secrets.SERVER_HOST }} << 'APACHE_CONFIG'
            set -euo pipefail
            
            echo "=== Configuring Apache Virtual Hosts ==="
            
            # Create HTTP virtual host configuration (no CORS headers - Laravel handles CORS)
            sudo tee /opt/bitnami/apache/conf/vhosts/docker-proxy.conf > /dev/null << 'HTTP_VHOST'
            # HTTP Virtual Hosts for Docker Development Containers
            <VirtualHost *:80>
                ServerName api.dev.livrolog.com
                ProxyPreserveHost On
                ProxyPass / http://127.0.0.1:8081/
                ProxyPassReverse / http://127.0.0.1:8081/
                ErrorLog /opt/bitnami/apache/logs/api-dev-error.log
                CustomLog /opt/bitnami/apache/logs/api-dev-access.log combined
            </VirtualHost>
            
            <VirtualHost *:80>
                ServerName dev.livrolog.com
                ProxyPreserveHost On
                ProxyPass / http://127.0.0.1:8080/
                ProxyPassReverse / http://127.0.0.1:8080/
                ErrorLog /opt/bitnami/apache/logs/dev-error.log
                CustomLog /opt/bitnami/apache/logs/dev-access.log combined
            </VirtualHost>
            HTTP_VHOST
            
            # Create HTTPS virtual host configuration (no CORS headers - Laravel handles CORS)
            sudo tee /opt/bitnami/apache/conf/bitnami/bitnami-ssl.conf > /dev/null << 'HTTPS_VHOST'
            # HTTPS Virtual Hosts for LivroLog Development
            
            <VirtualHost *:443>
                ServerName dev.livrolog.com
                ServerAlias www.dev.livrolog.com
            
                SSLEngine on
                SSLCertificateFile /etc/letsencrypt/live/dev.livrolog.com/fullchain.pem
                SSLCertificateKeyFile /etc/letsencrypt/live/dev.livrolog.com/privkey.pem
            
                # Proxy to Docker Web container
                ProxyPreserveHost On
                ProxyPass / http://127.0.0.1:8080/
                ProxyPassReverse / http://127.0.0.1:8080/
            
                ErrorLog /opt/bitnami/apache/logs/dev-ssl-error.log
                CustomLog /opt/bitnami/apache/logs/dev-ssl-access.log combined
            </VirtualHost>
            
            <VirtualHost *:443>
                ServerName api.dev.livrolog.com
            
                SSLEngine on
                SSLCertificateFile /etc/letsencrypt/live/dev.livrolog.com/fullchain.pem
                SSLCertificateKeyFile /etc/letsencrypt/live/dev.livrolog.com/privkey.pem
            
                # Proxy to Docker API container - NO CORS headers (Laravel handles CORS)
                ProxyPreserveHost On
                ProxyPass / http://127.0.0.1:8081/
                ProxyPassReverse / http://127.0.0.1:8081/
                
                ErrorLog /opt/bitnami/apache/logs/api-dev-ssl-error.log
                CustomLog /opt/bitnami/apache/logs/api-dev-ssl-access.log combined
            </VirtualHost>
            
            # Keep production SSL configs (api.livrolog.com and livrolog.com)
            <VirtualHost *:443>
                ServerName api.livrolog.com
            
                SSLEngine on
                SSLCertificateFile /etc/letsencrypt/live/livrolog.com/cert.pem
                SSLCertificateKeyFile /etc/letsencrypt/live/livrolog.com/privkey.pem
                SSLCertificateChainFile /etc/letsencrypt/live/livrolog.com/chain.pem
            
                # Enable proxy modules
                ProxyPreserveHost On
                ProxyPass / http://127.0.0.1:18081/
                ProxyPassReverse / http://127.0.0.1:18081/
            
                ErrorLog /opt/bitnami/apache/logs/api-livrolog_error.log
                CustomLog /opt/bitnami/apache/logs/api-livrolog_access.log combined
            
                # Redirect HTTP to HTTPS
                RewriteEngine On
                RewriteCond %{HTTPS} !=on
                RewriteRule ^/(.*) https://%{SERVER_NAME}/ [R,L]
            </VirtualHost>
            
            <VirtualHost *:443>
                ServerName livrolog.com
                ServerAlias www.livrolog.com
                DocumentRoot /var/www/livrolog/current/webapp
            
                SSLEngine on
                SSLCertificateFile /etc/letsencrypt/live/livrolog.com/fullchain.pem
                SSLCertificateKeyFile /etc/letsencrypt/live/livrolog.com/privkey.pem
            
                Header always set Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://accounts.google.com https://www.googletagmanager.com https://www.google-analytics.com; script-src-elem 'self' 'unsafe-eval' 'unsafe-inline' https://accounts.google.com https://www.googletagmanager.com https://www.google-analytics.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; style-src-elem 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https: http:; connect-src 'self' https://api.dev.livrolog.com https://api.livrolog.com https://accounts.google.com https://www.googleapis.com https://www.google-analytics.com https://analytics.google.com; frame-src https://accounts.google.com; object-src 'none'; base-uri 'self'"
            
                <Directory "/var/www/livrolog/current/webapp">
                    Options Indexes FollowSymLinks
                    AllowOverride All
                    Require all granted
                </Directory>
            </VirtualHost>
            HTTPS_VHOST
            
            # Test Apache configuration
            echo "üîç Testing Apache configuration..."
            if sudo /opt/bitnami/apache/bin/httpd -t; then
                echo "‚úÖ Apache configuration test passed"
                
                # Reload Apache to apply new configuration
                echo "üîÑ Reloading Apache configuration..."
                sudo pkill -f httpd || true
                sleep 3
                sudo /opt/bitnami/apache/bin/httpd &
                sleep 5
                
                echo "‚úÖ Apache proxy configuration applied successfully"
                echo "üåê Development sites should now be accessible:"
                echo "  ‚Ä¢ https://dev.livrolog.com (Web Frontend)"
                echo "  ‚Ä¢ https://api.dev.livrolog.com (API Backend)"
            else
                echo "‚ùå Apache configuration test failed"
                exit 1
            fi
            
          APACHE_CONFIG

      - name: Post-deployment verification
        run: |
          echo "üîç Running post-deployment verification..."
          
          # Final connectivity tests
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:8081/healthz || echo "FAIL")
          WEB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:8080/ || echo "FAIL")
          
          echo "Final Status Check:"
          echo "  API Health: $API_STATUS"
          echo "  Web Status: $WEB_STATUS"
          
          if [ "$API_STATUS" = "200" ] && [ "$WEB_STATUS" = "200" ]; then
            echo "‚úÖ All services are healthy and accessible"
          else
            echo "‚ö†Ô∏è Some services may not be fully ready yet"
            echo "This is normal for large applications and they should be ready shortly"
          fi
          
          echo "üéØ Development deployment verification completed"

  docker-canary-prod:
    name: docker-canary-prod
    runs-on: ubuntu-latest
    needs: [required-checks, build]
    if: always() && needs.build.result == 'success' && (github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'main'))

    env:
      ENVIRONMENT: Production
      TARGET_BRANCH: main
      DEPLOY_PATH: /var/www/livrolog
      GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
      GITHUB_SHA: ${{ github.sha }}
      GITHUB_REF_NAME: ${{ github.ref_name }}

    steps:
      - name: Checkout code for compose file
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate required secrets
        run: |
          echo "üîç Validating required secrets and environment variables..."
          
          # Check required secrets
          if [ -z "${{ secrets.SERVER_HOST }}" ]; then
            echo "‚ùå SERVER_HOST secret is not configured"
            exit 1
          fi
          
          if [ -z "${{ secrets.SERVER_USER }}" ]; then
            echo "‚ùå SERVER_USER secret is not configured" 
            exit 1
          fi
          
          if [ -z "${{ secrets.SERVER_SSH_KEY }}" ]; then
            echo "‚ùå SERVER_SSH_KEY secret is not configured"
            exit 1
          fi
          
          # APP_KEY is required for production
          if [ -z "${{ secrets.APP_KEY }}" ]; then
            echo "‚ùå APP_KEY secret is not configured for production"
            exit 1
          fi
          
          # DB_PASSWORD is required for production
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "‚ùå DB_PASSWORD secret is not configured for production"
            exit 1
          fi
          
          # GHCR_PAT is optional for public images, but warn if missing
          if [ -z "${{ secrets.GHCR_PAT }}" ]; then
            echo "‚ö†Ô∏è GHCR_PAT secret not found - will attempt to pull public images"
          fi
          
          echo "‚úÖ Secret validation completed"

      - name: Setup SSH key and test connection
        run: |
          echo "üîê Setting up SSH connection..."
          
          # Create SSH directory and set permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Create SSH private key file
          echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/livrolog_key
          chmod 600 ~/.ssh/livrolog_key
          
          # Disable host key checking for this deployment (AWS instances change IPs)
          echo "Host ${{ secrets.SERVER_HOST }}" >> ~/.ssh/config
          echo "  HostName ${{ secrets.SERVER_HOST }}" >> ~/.ssh/config
          echo "  User ${{ secrets.SERVER_USER }}" >> ~/.ssh/config
          echo "  IdentityFile ~/.ssh/livrolog_key" >> ~/.ssh/config
          echo "  StrictHostKeyChecking no" >> ~/.ssh/config
          echo "  UserKnownHostsFile /dev/null" >> ~/.ssh/config
          echo "  LogLevel QUIET" >> ~/.ssh/config
          chmod 600 ~/.ssh/config
          
          # Test SSH connection
          echo "üîç Testing SSH connection to ${{ secrets.SERVER_HOST }}..."
          if ssh ${{ secrets.SERVER_HOST }} "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connection test passed"
          else
            echo "‚ùå SSH connection test failed"
            echo "Debug information:"
            echo "  Host: ${{ secrets.SERVER_HOST }}"
            echo "  User: ${{ secrets.SERVER_USER }}"
            echo "  Key length: ${#{{ secrets.SERVER_SSH_KEY }}}"
            exit 1
          fi

      - name: Copy compose file to server
        run: |
          echo "üìÅ Copying docker-compose.prod.yml to server..."
          
          # Create target directory on server
          ssh ${{ secrets.SERVER_HOST }} "sudo mkdir -p ${DEPLOY_PATH}/docker && sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} ${DEPLOY_PATH}"
          
          # Copy compose file
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml ${{ secrets.SERVER_HOST }}:${DEPLOY_PATH}/docker/
          
          echo "‚úÖ Docker compose file copied successfully"

      - name: Deploy production containers  
        run: |
          ssh ${{ secrets.SERVER_HOST }} << 'DEPLOY_SCRIPT'
            set -euo pipefail
            # Configuration
            DOCKER_DIR="${{ env.DEPLOY_PATH }}/docker"
            SHARED_DIR="${{ env.DEPLOY_PATH }}/shared"
            OWNER="${{ env.GITHUB_REPOSITORY_OWNER }}"
            TAG="prod"
            IMAGE_API="ghcr.io/${OWNER}/livrolog-api"
            IMAGE_WEB="ghcr.io/${OWNER}/livrolog-web"
            
            echo "=================================================="
            echo "üöÄ LivroLog Production Deployment"
            echo "Branch: ${{ env.TARGET_BRANCH }}"
            echo "SHA: ${{ env.GITHUB_SHA }}"
            echo "Images: ${IMAGE_API}:${TAG}, ${IMAGE_WEB}:${TAG}"
            echo "Deploy Path: ${{ env.DEPLOY_PATH }}"
            echo "=================================================="
            
            # Create required directories with proper permissions
            echo "üìÅ Setting up directories and permissions..."
            sudo mkdir -p "${SHARED_DIR}"/{storage,db}
            sudo mkdir -p "${DOCKER_DIR}"
            
            # Set MariaDB data directory permissions (UID 999)
            sudo chown -R 999:999 "${SHARED_DIR}/db"
            
            # Set Laravel storage permissions (www-data)
            sudo chown -R www-data:www-data "${SHARED_DIR}/storage" 2>/dev/null || sudo chown -R 82:82 "${SHARED_DIR}/storage"
            
            # Set deployment directory permissions
            sudo chown -R ${{ secrets.SERVER_USER }}:${{ secrets.SERVER_USER }} "${{ env.DEPLOY_PATH }}"
            
            # Create production environment file
            echo "üìù Creating production .env file..."
            cat > "${SHARED_DIR}/.env.prod" << 'ENV_EOF'
            APP_NAME=LivroLog
            APP_ENV=production
            APP_KEY=${{ secrets.APP_KEY }}
            APP_DEBUG=false
            APP_TIMEZONE=UTC
            
            DB_CONNECTION=mysql
            DB_HOST=mariadb
            DB_PORT=3306
            DB_DATABASE=livrolog
            DB_USERNAME=root
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            
            REDIS_CLIENT=predis
            REDIS_HOST=redis
            REDIS_PASSWORD=null
            REDIS_PORT=6379
            
            QUEUE_CONNECTION=redis
            SESSION_DRIVER=redis
            SESSION_LIFETIME=120
            CACHE_DRIVER=redis
            MAIL_MAILER=log
            LOG_CHANNEL=stack
            LOG_LEVEL=error
            ENV_EOF
            
            echo "‚úÖ Environment file created"

            # Navigate to docker directory
            cd "${DOCKER_DIR}"
            
            # Login to GitHub Container Registry if PAT available
            if [ -n "${{ secrets.GHCR_PAT }}" ]; then
              echo "üîê Authenticating with GitHub Container Registry..."
              echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u "${{ env.GITHUB_REPOSITORY_OWNER }}" --password-stdin
            else
              echo "‚ö†Ô∏è No GHCR_PAT provided - attempting to pull public images"
            fi
            
            # Pull latest images with error handling
            echo "üì¶ Pulling latest Docker images..."
            if ! docker pull "${IMAGE_API}:${TAG}"; then
              echo "‚ö†Ô∏è Failed to pull API image ${IMAGE_API}:${TAG}"
              echo "Available API tags:"
              docker images | grep livrolog-api || echo "No local API images found"
            fi
            
            if ! docker pull "${IMAGE_WEB}:${TAG}"; then
              echo "‚ö†Ô∏è Failed to pull Web image ${IMAGE_WEB}:${TAG}"
              echo "Available Web tags:"
              docker images | grep livrolog-web || echo "No local Web images found"
            fi
            
            # Stop existing containers gracefully
            echo "üõë Stopping existing production containers..."
            if docker compose -f docker-compose.prod.yml ps --services --filter "status=running" | grep -q .; then
              docker compose -f docker-compose.prod.yml down --timeout 30
              echo "‚úÖ Existing containers stopped"
            else
              echo "‚ÑπÔ∏è No running containers to stop"
            fi
            
            # Clean up orphaned containers and networks
            echo "üßπ Cleaning up orphaned resources..."
            docker container prune -f --filter "label=com.docker.compose.project=livrolog" || true
            docker network prune -f || true
            
            # Export environment variables for docker-compose
            export GITHUB_REPOSITORY_OWNER="${OWNER}"
            export TAG="${TAG}"
            export DB_DATABASE="livrolog"
            export DB_USERNAME="root"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            
            # Start containers with health checks
            echo "üöÄ Starting production containers..."
            if ! docker compose -f docker-compose.prod.yml up -d --remove-orphans; then
              echo "‚ùå Failed to start containers"
              echo "=== Docker Compose Logs ==="
              docker compose -f docker-compose.prod.yml logs --tail=50
              exit 1
            fi
            
            echo "‚úÖ Containers started successfully"
            
            # Wait for containers to initialize
            echo "‚è≥ Waiting for containers to initialize (90 seconds)..."
            sleep 90
            
            # Health checks with detailed status
            echo "üîç Performing health checks..."
            
            # Check container status
            echo "üìä Container Status:"
            docker compose -f docker-compose.prod.yml ps
            
            # Check MariaDB connectivity
            echo "üîç Testing MariaDB connectivity..."
            for i in {1..18}; do
              if docker exec livrolog-mariadb-1 mysqladmin ping -u root -p${{ secrets.DB_PASSWORD }} --silent 2>/dev/null; then
                echo "‚úÖ MariaDB is responding (attempt $i)"
                break
              elif [ $i -eq 18 ]; then
                echo "‚ùå MariaDB health check failed after 18 attempts"
                docker logs livrolog-mariadb-1 --tail=30
                exit 1
              else
                echo "‚è≥ MariaDB not ready yet (attempt $i/18), waiting 10 seconds..."
                sleep 10
              fi
            done
            
            # Check Redis connectivity  
            echo "üîç Testing Redis connectivity..."
            if docker exec livrolog-redis-1 redis-cli ping >/dev/null 2>&1; then
              echo "‚úÖ Redis is responding"
            else
              echo "‚ùå Redis health check failed"
              docker logs livrolog-redis-1 --tail=20
              exit 1
            fi
            
            # Check API health endpoint
            echo "üîç Testing API health endpoint..."
            for i in {1..30}; do  
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:18081/healthz 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ API health endpoint responding (HTTP $HTTP_CODE)"
                break
              elif [ $i -eq 30 ]; then
                echo "‚ùå API health endpoint failed after 30 attempts (HTTP $HTTP_CODE)"
                echo "=== API Container Logs ==="
                docker logs livrolog-api-1 --tail=50
                exit 1
              else
                echo "‚è≥ API not ready yet (HTTP $HTTP_CODE, attempt $i/30), waiting 10 seconds..."
                sleep 10
              fi
            done
            
            # Check Web frontend
            echo "üîç Testing Web frontend..."  
            for i in {1..18}; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:18080/ 2>/dev/null || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "‚úÖ Web frontend responding (HTTP $HTTP_CODE)"
                break
              elif [ $i -eq 18 ]; then
                echo "‚ùå Web frontend failed after 18 attempts (HTTP $HTTP_CODE)"
                echo "=== Web Container Logs ==="
                docker logs livrolog-web-1 --tail=30
                exit 1
              else
                echo "‚è≥ Web not ready yet (HTTP $HTTP_CODE, attempt $i/18), waiting 5 seconds..."
                sleep 5
              fi
            done
            
            # Run Laravel migrations and optimizations
            echo "üîÑ Running Laravel migrations and optimizations..."
            API_CONTAINER=$(docker compose -f docker-compose.prod.yml ps -q api)
            if [ -n "$API_CONTAINER" ]; then
              docker exec "$API_CONTAINER" php artisan migrate --force
              docker exec "$API_CONTAINER" php artisan config:cache
              docker exec "$API_CONTAINER" php artisan route:cache
              docker exec "$API_CONTAINER" php artisan view:cache
              echo "‚úÖ Laravel optimizations completed"
            else
              echo "‚ö†Ô∏è API container not found for Laravel commands"
            fi
            
            echo "=================================================="
            echo "üéâ Production deployment completed successfully!"
            echo "üìç Services:"
            echo "  ‚Ä¢ Web Frontend: https://livrolog.com"
            echo "  ‚Ä¢ API Backend: https://api.livrolog.com"
            echo "  ‚Ä¢ Internal Web: http://127.0.0.1:18080"
            echo "  ‚Ä¢ Internal API: http://127.0.0.1:18081"
            echo "=================================================="
            
          DEPLOY_SCRIPT

      - name: Post-deployment verification
        run: |
          echo "üîç Running post-deployment verification..."
          
          # Final connectivity tests
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:18081/healthz || echo "FAIL")
          WEB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:18080/ || echo "FAIL")
          
          echo "Final Status Check:"
          echo "  API Health: $API_STATUS"
          echo "  Web Status: $WEB_STATUS"
          
          if [ "$API_STATUS" = "200" ] && [ "$WEB_STATUS" = "200" ]; then
            echo "‚úÖ All services are healthy and accessible"
          else
            echo "‚ö†Ô∏è Some services may not be fully ready yet"
            echo "This is normal for large applications and they should be ready shortly"
          fi
          
          echo "üéØ Production deployment verification completed"
